var colors = require('util/colors');
var ejs = require('ejs');
var path_module = require('path');
var fs = require('fs');

function _next_measure(i, input) {
    var out = null;

    input.forEach(function(m) {
        if (m.height >= i) {
            if (out) {
                if (out.height > m.height) {
                    out = m;
                }
            } else {
                out = m;
            }
        }
    });
    return out;
}

function _prev_measure(i, input) {
    var out = null;

    input.forEach(function(m) {
        if (m.height <= i) {
            if (out) {
                if (out.height < m.height) {
                    out = m;
                }
            } else {
                out = m;
            }
        }
    });
    return out;
}

function _linear(p1, a, b) {
    return ((p1 * a) + ((1 - p1) * b));
}

function _extrapolate(i, p, n) {
    var range = n.height - p.height;
    var extent = i - p.height;
    var progress = 1 - (extent / range);

    var h = _linear(progress, p.hsv[0], n.hsv[0]);
    var s = _linear(progress, p.hsv[1], n.hsv[1]);
    var v = _linear(progress, p.hsv[2], n.hsv[2]);

    return {
        height: i,
        hsv: [h, s, v],
        rgb: colors.hsv_to_rgb(h, s, v)
    };
}

module.exports = {
    measure: function(height, r, g, b) {
        return {
            height: height,
            rgb: [r, g, b],
            hsv: colors.rgb_to_hsv(r, g, b)
        };
    },

    last_prev: null,
    last_next: null,
    last_item: null,
    last_scale: null,

    nearest: function(height, scale) {
        var cl_index = scale.length - 1;
        var floor_index = 0;
        var floor_item = scale[floor_index];
        var cl_item = scale[cl_index];
        
        if (height <= floor_item.height) {
            return scale[floor_index];
        } else if (height >= cl_item.height) {
            return scale[cl_index];
        }

        var check_index = Math.floor(scale.length / 2);
        
        while (true) {

            var item = scale[check_index];
            if (item.height == height) {
                return item;
            } else if (item.height > height) {
                cl_index = check_index;
                ciel_item = item;
                check_index = Math.floor((check_index + floor_index) / 2);
            } else { // item.height < height)
                floor_index = check_index;
                floor_item = item;
                check_index = Math.floor((check_index + cl_index) / 2);
            }

            if (cl_index - floor_index < 3){
                var item = scale[check_index];
                
                var floor_item = scale[floor_index];
                var cl_item = scale[cl_index];
                
                var spr = Math.abs(height - floor_item.height);
                var ret_item = floor_item;
                
                var it_spr = Math.abs(height - item.height);
                if (it_spr < spr){
                    ret_item = item;
                    spr = it_spr;
                }
                
                var cl_spr = Math.abs(height - cl_item.height);
                if (cl_spr < spr){
                    return cl_item;
                } else {
                    return ret_item;
                }
            }
            
        }

    },

    _mid_angle: function(a, b) {
        a += 360;
        a %= 360;

        b += 360;
        b %= 360;

        if (a > b) {
            var m = a;
            a = b;
            b = m;
        } // now a is < b;
        if ((b - a) > 180) {
            a += 360;
            var dif = a - b;
            b += dif / 2;
            return parseInt(b) % 360;
        } else {
            var dif = b - a;
            a += dif / 2;
            return parseInt(a) % 360;
        }
    },

    _blend: function(n, p) {
        var h = this._mid_angle(p.hsv[0], n.hsv[0]);
        var s = parseInt((p.hsv[1] + n.hsv[1]) / 2);
        var v = parseInt((p.hsv[2] + n.hsv[2]) / 2);

        return {
            height: parseInt((n.height + p.height) / 2),
            hsv: [h, s, v],
            rgb: colors.hsv_to_rgb(h, s, v)
        };
    },

    scale: function(input, iterations) {
        while (iterations-- > 0) {
            var first = input.shift();
            var new_input = [first];
            while (input.length) {
                var next = input.shift();
                new_input.push(this._blend(first, next));
                new_input.push(next);
                first = next;
            }
            input = new_input;
        }

        return input;
    }
}