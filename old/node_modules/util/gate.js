/**
 * This module allows you to track aggregate activity and
 * execute one or more callbacks when your tasks clear.
 * It is not necessary to identify individual tasks as
 * the only thing this class cares about is the quantity of tasks in the queue.
 *
 * However for future proofing, tasks are identified and optionally removed by name. 
 */

module.exports = function(callbacks, params) {
    this._params = params ? params : {};
    this._tasks = [];
    this._start = false;
    this.debug = false;
    this.interval = 100;
    this._callbacks = typeof(callbacks) == 'function' ? [callbacks] : _.isArray(callbacks) ? callbacks : [];
}

module.exports.prototype.start = function() {
    this._start = true;
    var self = this;
    if (this.debug) {
        // console.log(__filename + ':: start starting with ' + this._tasks.length + ' tasks');
    }
    var i = setInterval(function() {
        if (!self._start) {
            clearInterval(i);
        } else {
            self._check_status();
        }
    }, this.interval);
}

module.exports.prototype.task_start = function(task) {
    if (!task) {
        task = this._tasks.length
    }
    this._tasks.push(task);
    if (this.debug) {
        console.log('gate task start');
        this._check_status();
    }
}


/**
 * @id scalar (optional)
 * returns either the designated task
 * or the last task in the queue. 
 */
module.exports.prototype.task_done = function() {

    if (this.debug) {
        console.log('gate task done');
    }
    var done_task = this._tasks.pop();
    this._check_status();
}

module.exports.prototype.task_done_callback = function(start_task) {
    var self = this;
    return function() {
        self.task_done();
    }
    if (start_task) {
        this.task_start();
    }
}

module.exports.prototype._check_status = function() {
    var self = this;

    if (this._start) {
        if (this._tasks.length < 1) {
            this._start = false;
            if (this.debug) {
                console.log(__filename + ':: _check_status: done with gate - calling ' + this._callbacks.length + ' callbacks');
            };
            this._callbacks.forEach(function(callback) {
                callback(self);
            });
        } else {
            if (this.debug) {
                console.log('task done; ', this._tasks.length, ' tasks left');
            }
        }
    } else {
        if (this.debug) {
            console.log('task done; ', this._tasks.length, ' tasks left - STILL NOT STARTED');
        }
    }
}

module.exports.prototype.run_callacks = function() {
    this._callbacks.forEach(function(err, callback) {
        callback(null, this);
    })
}