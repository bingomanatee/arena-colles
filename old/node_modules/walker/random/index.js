var Walk = require('./walk');
var Gate = require('util/gate');
var models_module = require(MVC_MODELS);

function Random_Walker(model) {
    this.model = model;
    this.count = 0;
    this.ol = 0;
}

Random_Walker.prototype = {

    start: function(steps, callback) {

      //  console.log(__filename, ': Random_Walker.walk(', steps, ')');
        walk = new Walk([{
            i: 0,
            j: 0
        }]);

        var self = this;
        this.model.put(walk.serialize(), function() {
            self.scatter(1, steps, callback);
        });

    },

    scatter: function(step, steps, callback) {
        if (step > steps){
            return callback();
        }
        var self = this;

        var gate = new Gate(
        function() {
            console.log('iterating to next step from ', step);
            self.scatter(step + 1, steps, callback);
        });

        tally = {count: 0, ol: 0};
        
        function _each(err, randomwalk) {
            if (randomwalk) {
        //        console.log('_each() - scattering ', randomwalk);
               self._scatter_record(randomwalk, gate);
              
            } else {
                console.log('starting gate at ', step);
                gate.start();
            }
        }
        
        var query = {
            steps: step
        }

       // console.log(__filename, 'scatter(', step, ', ' , steps, '), query = ', query);
        
        this.model.find(query, function(err, cursor) {
            cursor.each(_each);
            console.log(step, ': tally - ', self.count, '; ol= ', self.ol);
        }, {
            cursor: true
        });
    },

    _scatter_record: function(randomwalk, gate) {
      //  console.log('walking from ', randomwalk);

        var walk = Walk.load(randomwalk);
        
        var walks = [];
        if (walk.last_direction() != 's') {
            walks.push(walk.n());
        }

        if (walk.last_direction() != 'n') {
            walks.push(walk.s());
        }

        if (walk.last_direction() != 'w') {
            walks.push(walk.e());
        }

        if (walk.last_direction() != 'e') {
            walks.push(walk.w());
        }
        
      //  console.log('..walk log: ', walks);

        var self = this;
        walks.forEach(function(walk) {
                var data = walk.serialize();
            if (walk.overlap()) {
                ++self.ol;
             //   console.log('... overlaps: ', data.points);
            } else {
                ++self.count;
                gate.task_start();
              //  console.log('serialized: ', data._id);
                self.model.put(data, function() {
                    gate.task_done();
                });
            }
        });
        
    }

}


module.exports = Random_Walker;