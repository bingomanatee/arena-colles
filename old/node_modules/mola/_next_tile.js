var Canvas = require('canvas');
var colors_to_id = require('util/canvas/colors_to_id');

module.exports = function() {
    if (!this.render_status) {
        return;
    }

    if (this._targets.length) {
        var ij = this._targets.pop();
    } else {
        this.render_status = false;
        console.log('$$$$$$$$$$$ ALL TILES RENDERED $$$$$$$$$$$$$$');
        console.log('$$$$$$$$$$$ ALL TILES RENDERED $$$$$$$$$$$$$$');
        return;
    }
    var self = this;
    var gate = new Gate(function() {
        self._next_tile();
    });
    //    gate.debug = true;
    var tile_i = ij[0];
    var tile_j = ij[1];

    var r = this._tile_row(tile_i);
    var c = this._tile_col(tile_j);
    var r_end = this._tile_row(tile_i + 1);
    var c_end = this._tile_col(tile_j + 1);

    var h = r_end - r;
    var w = c_end - c;

    var data = null;
    var opt_data = null;

    var canvas = null;
    var ctx = null;
    var id = null;

    function _do_tile(config) {
        skip = 0;
        console.log('starting ', tile_i, ',', tile_j, '(', w, ' x ', h, ')');
        if (!data) {
            data = self.tile_data(tile_i, tile_j);
            opt_data = self._opt_data(data);
            console.log('data: ', data.length, ', expected: ', w * h);
        }
        if ((!canvas) || (!(canvas.width == w)) || (!(canvas.height == h))) {
            canvas = new Canvas(w, h);
            ctx = canvas.getContext('2d');
            id = ctx.getImageData(0, 0, w, h);
        }
        ctx.fillStyle = '#F00';
        ctx.fillRect(0, 0, w, h);
        var t = new Date().getTime();
        //        var colors = self._height_to_image_data(data, config);
        var colors = self._opt_to_colors(opt_data, config, w * h);
        colors_to_id(colors, id);
        ctx.putImageData(id, 0, 0);

        var c_path = config.path(self, tile_i, tile_j);
        fs_utils.ensure_file_path(c_path);
        console.log('rendering ', c_path);
        gate.task_start();
        // cti(canvas, c_path, gate.task_done_callback());
        canvas.toBuffer(function(err, buf) {
            if (err) throw err;
            fs.writeFile(c_path, buf, gate.task_done_callback());
        });
    }

    self.chop_layers.forEach(function(config) {
        var c_path = config.path(self, tile_i, tile_j);
        if (pm.existsSync(c_path)) {
            if ((++skip < 3) || (!(skip % 50))) {
                console.log('skipping ', c_path);
            }
        } else if (self.data.length) {
            _do_tile(config);
        } else if (!self.reading_data) {
            self.reading_data = true;
            self.read(function() {
                _do_tile(config)
            });
        }
    });
    gate.start();
}