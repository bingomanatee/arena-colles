var Model = require('mvc/model');
var mongo = require('mongodb');
var BSON = mongo.BSONPure;
var db = require(MVC_MODELS + '/db');
var util = require('util');

/*
 ' Note - there are differences between methods like find and all
 * and analogous methods in the collection class.
 * in the case of get, one object is returned from the collection
 * (not an array of objects).
 * find and all returns an array of objects, not a cursor.
 * 
 */
module.exports = exports = {

    init: function(model_module, callback) {
        if (model_module.hasOwnProperty(config)) {
            var config = model_module.config;
        } else {
            var config = {};
        }

        if (model_module.hasOwnProperty('mixins')) {
            var mixins = model_module.mixins;
        } else {
            var mixins = {};
        }

        if (model_module.hasOwnProperty('name')) {
            var name = model_module.name;
        } else if (model_module.hasOwnProperty('collection')) {
            var name = model_module.collection;
        };

        if (!name) {
            callback(new Error('cannot find model name.'));
        } else {
            //     // console.log(__filename, ':: init: mixins for ', name, ', mixins: ', mixins);
            this.make_model(name, config, mixins, function(err, model) {
                if (err) {
                    callback(err);
                } else {
                    model_module._model = model;
                    if (model.on_load) {
                        console.log('initializing model ', name, ' on_load', model.on_load);
                        model.on_load(model, callback);
                    } else {
                        console.log('NOT initializing model ', name, ' on_load');
                        callback(null, model);
                    }
                }
            });
        }
    },

    _db: null,

    make_model: function(coll_name, config, mixins, callback) {
        var self = this;

        if (!config) {
            config = {};
        }

        //     // console.log(__filename, '::make_model: mixins for ', coll_name, ', mixins: ', mixins);
        /**
         * Load the database from the default if there is no database
         * passed through the config.
         * 
         */
        if (config.db) {
            this._make_model(coll_name, config, mixins, callback);
        } else if (self._db) {
            config.db = self._db;
            this._make_model(coll_name, config, mixins, callback);
        } else {
            //  console.log(__filename, ': opening default database for ', coll_name);
            return db.open(function(err, db) {
                if (err) {
                    // console.log(__filename, ': ERROR OPENING DATABSE: ', err);
                    return callback(err);
                }
                self._db = config.db = db; // recurse once with new DB. 
                //  console.log(__filename, ': getting collection for ', coll_name);
                self._make_model(coll_name, config, mixins, callback);
            });
        }

        // console.log(__filename, ': getting collection for ', coll_name);
    },

    _make_model: function(coll_name, config, mixins, callback) {
        // console.log(__filename, ': _make_model: making ', coll_name, ': mixins ', mixins);
        if (typeof(mixins) == 'function') {
            callback = mixins;
            mixins = {};
        }

        if (!typeof(callback) == 'function') {
            throw new Exception(__filename + ': no callback for ' + coll_name);
        }

        config.db.collection(coll_name, function(err, coll) {
            if (err) {
                // console.log(__filename, ':: make_model: error making collection ' + coll_name, err);
                callback(err);
            } else {
                config.coll = coll;
                var name = config.db.databaseName + '.' + coll_name;
                var mongo_model = new Model(name, null, config, module.exports.mixins);
                if (mixins) {
                    _.extend(mongo_model, mixins);
                }
                mongo_model.collection = coll_name;
                // console.log(__filename, ':: returning model');
                callback(null, mongo_model);
            };
        })
    },

    mixins: {

        name: function() {
            return this.config.collection.collectionName;
        },

        all: function(callback, options) {
            q = this.soft_delete ? {
                deleted: {
                    "$ne": true
                }
            } : {};
            this.find(q, callback, options);
        },

        count: function(q, callback) {
            return this.config.coll.count(q, callback);
        },

        _as_oid: function(id) {
            var mongo = require('mongodb');
            var BSON = mongo.BSONPure;
            //   console.log(__filename + '::_as_oid: id ' + id);
            if (typeof(id) == 'string') {
                if (this.string_id) {
                    //    console.log(__filename, ' (as string)');
                    var out = id;
                } else {
                    var out = new BSON.ObjectID(id);
                    console.log('BSONifying ', id, ', out = ', util.inspect(out), ': type = ', typeof out);
                }
            } else {
                //   console.log(__filename, 'id != string: ', id);
                var out = id;
            }

            //  console.log(__filename, ': input: ', id, ', returning: ', out, ': type: ', typeof out);
            return out;
        },

        string_id: false,

        get: function(id, callback) {
            if (!(typeof(callback) == 'function')) {
                throw new Error(__filename + ':: get no callback for ' + this.collection);
            }
            // console.log(__filename + '::get id ' + id);
            if (!this.hasOwnProperty('_as_oid')) {
                throw new Error('no _as_oid');
            }
            id = this._as_oid(id);
            // console.log(id);
            this.find({
                _id: id
            }, function(err, result) {
                callback(err, result ? result[0] : null);
            });
        },

        "find_and_delete": function(query, callback) {
            this.config.coll.remove(query, callback);
        },

        "delete": function(id, callback) {
            // console.log(__filename + ':: deleting ');
            var query = {
                _id: this._as_oid(id)
            };
            // console.log(query);
            if (this.soft_delete) {
                // console.log(__filename + ': soft deleting');
                this.config.coll.findAndModify(query, null, {
                    "deleted": true
                }, true, false, callback);
            } else if (this.config.coll) {
                this.config.coll.remove(query, callback);
            } else {
                callback(new Error('No Connection'));
            }

        },

        put: function(data, callback) {
            var self = this;

            if (this.config.coll) {
                if (data._id) {
                    console.log(__filename, ': putting with ID: ', data);
                    data._id = self._as_oid(data._id);
                }
                this.insert(data, callback);
            } else {
                callback(new Error('No Collection'));
            }
        },

        insert: function(data, callback) {
            //  console.log('inserting mongo data ');
            console.log(data);
            this.config.coll.insert(data, callback);
        },

        soft_delete: false,

        delete: function(id, callback) {
            var self = this;

            this.get(id, function(err, data) {
                if (err) {
                    callback(err);
                } else if (!data) {
                    callback(new Error('no record found'))
                } else if (self.soft_delete) {
                    data.deleted = true;
                    self.put(data, callback);
                } else {
                    this.config.callback.delete(data, callback);
                }
            });
        },

        update: function(data, callback, filter, options) {
            if (this.config.coll) {
                if (!filter) {
                    if (data._id) {
                        filter = {
                            _id: data._id
                        };
                    } else {
                        callback(new Error('attempt to update with no filter'));
                    }
                }
                console.log(__filename + '::update updating where ', filter, ': data = ', data);
                this.config.coll.update(filter, data, options, callback);
            } else {
                callback(new Error('No Connection'));
            }
        },

        find: function(query, callback, options) {
            if (typeof(query) == 'function') {
                callback = query;
                query = {};
            }

            //  console.log(__filename = ':: find query = ', query, ' callback = ' , callback);
            if (typeof(callback) != 'function') {
                throw new Error(__filename + '::find:: no callback');
            }
            if (this.config.coll) {
                if (options && options.hasOwnProperty('cursor') && options.cursor) {
                    handle = callback;
                } else {
                    var handle = function(err, cursor) {
                        if (err) {
                            // console.log('error in finding ');
                            callback(err);
                        } else {
                            cursor.toArray(function(err, values) {
                                //    // console.log(__filename, '::find cursor: err', err, ' values: ', values);
                                callback(err, values);
                            });
                        }
                    }
                }

                // console.log(__filename + '::find:: finding ');
                // console.log(query);
                if (options) {
                    if (options.hasOwnProperty('fields')) {
                        fields = options.fields;
                        delete options.fields;
                        this.config.coll.find(query, fields, options, handle);
                    } else {
                        this.config.coll.find(query, options, handle);
                    }
                } else {
                    this.config.coll.find(query, handle);
                }
            } else {
                callback(new Error('No Connection'));
            }
        }
    }
}