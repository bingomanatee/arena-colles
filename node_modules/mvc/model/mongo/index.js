var Model = require('mvc/model');
var mongo = require('mongodb');
var BSON = mongo.BSONPure;
var db = require(MVC_MODELS + '/db');
var util = require('util');

/*
 ' Note - there are differences between methods like find and all
 * and analogous methods in the collection class.
 * in the case of get, one object is returned from the collection
 * (not an array of objects).
 * find and all returns an array of objects, not a cursor.
 * 
 */
module.exports = exports = {

    init: require('./init'),

    _db: null,

    make_model: function(coll_name, config, mixins, callback) {
        var self = this;

        if (!config) {
            config = {};
        }

        /**
         * Load the database from the default if there is no database
         * passed through the config.
         * 
         */
        if (config.db) {
            this._make_model(coll_name, config, mixins, callback);
        } else if (self._db) {
            config.db = self._db;
            self._make_model(coll_name, config, mixins, callback);
        } else {
            //  console.log(__filename, ': opening default database for ', coll_name);
            return db.open(function(err, db) {
                if (err) {
                    // console.log(__filename, ': ERROR OPENING DATABSE: ', err);
                    return callback(err);
                }
                self._db = config.db = db; // recurse once with new DB. 
                //  console.log(__filename, ': getting collection for ', coll_name);
                self._make_model(coll_name, config, mixins, callback);
            });
        }

        // console.log(__filename, ': getting collection for ', coll_name);
    },

    _make_model: function(coll_name, config, mixins, callback) {
        // console.log(__filename, ': _make_model: making ', coll_name, ': mixins ', mixins);
        if (typeof(mixins) == 'function') {
            callback = mixins;
            mixins = {};
        }

        if (!typeof(callback) == 'function') {
            throw new Exception(__filename + ': no callback for ' + coll_name);
        }
        config.db.collection(coll_name, function(err, coll) {
            if (err) {
                // console.log(__filename, ':: make_model: error making collection ' + coll_name, err);
                callback(err);
            } else {
                config.coll = coll;
                var name = config.db.databaseName + '.' + coll_name;
                var mongo_model = new Model(name, null, config, module.exports.mixins);
                if (mixins) {
                    _.extend(mongo_model, mixins);
                }
                mongo_model.collection = coll_name;
                // console.log(__filename, ':: returning model');
                callback(null, mongo_model);
            };
        })
    },

    mixins: {

        name: function() {
            return this.config.collection.collectionName;
        },

        drop: function(callback) {
            this.config.coll.drop(callback);
        },

        all: function(callback, options) {
            q = this.soft_delete ? {
                deleted: {
                    "$ne": true
                }
            } : {};
            this.find(q, callback, options);
        },

        command: function(c, callback) {
            this.config.db.command(c, callback);
        },

        count: function(q, callback) {
            return this.config.coll.count(q, callback);
        },

        _as_oid: require('./as_oid'),

        string_id: false,

        get: require('./get'),

        "find_and_delete": function(query, callback) {
            this.config.coll.remove(query, callback);
        },

        put: require('./put'),

        insert: function(data, callback) {
            this.config.coll.insert(data, callback);
        },

        soft_delete: false,

        delete: require('./delete'),

        update: require('./update'),

        index: function(data, callback) {
            this.config.coll.createIndex(data, callback);
        },

        find: require('./find')
    }
}