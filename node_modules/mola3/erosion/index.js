var util = require('util');
var _ = require('underscore');
var Terrain = require('./Terrain.js');

function _rain(cell) {
    cell.water += cell.terrain.erosion._rain_amount(cell);
}

function _flux(cell, neighbor, dir) {
    var drop = cell.water_height() - neighbor.water_height();
    var flow;
    if (drop <= 0) {
        flow = 0;
    } else {
        flow = drop * cell.terrain.erosion.flow_friction;
    }

    cell.flux[dir] = flow;
    cell.total_flux += flow;
}

function _calculate_flux(cell) {

    cell.total_flux = 0;
    cell.each_neighbor(_flux);

    if (cell.total_flux > cell.water) {
        var k = cell.water / cell.total_flux;

        for (var dir in cell.flux) {
            cell.flux[dir] *= k;
        }
    }

}


function _dist(x, y) {
    return Math.sqrt((x * x) + (y * y));
}

function _flow_vector_dim(cell, neg, pos) {
    var a = 0;

    if (cell.flux[neg]) {
        a -= cell.flux[neg];
    }
    if (cell.neighbors[neg]) {
        if (cell.neighbors[neg].flux[pos]) {
            a += cell.neighbors[neg].flux[pos];
        }
    }
    if (cell.flux[pos]) {
        a += cell.flux[pos];
    }
    if (cell.neighbors[pos]) {
        if (cell.neighbors[pos].flux[neg]) {
            a -= cell.neighbors[pos].flux[neg];
        }
    }

    return a;
}

function _flow_vector(cell) {

    var flow_x = _flow_vector_dim(cell, 'l', 'r');

    var flow_y = _flow_vector_dim(cell, 't', 'b');

    return {x:flow_x, y:flow_y, d:_dist(flow_x, flow_y)};
}

function _save_flow_vector(cell) {
    cell.flow_vector = _flow_vector(cell);
}

function _release_flux(cell) {
    function _move_flux(cell, neighbor, dir) {
        var flow = cell.flux[dir]
        if (flow) {
            cell.water -= flow;
            neighbor.water += flow;
        }
    }

    cell.each_neighbor(_move_flux);
}

var rad = {};

for (var a = 0; a <= 360; a += 5) {
    rad['d' + a] = a * Math.PI / 180;
}

function _vector_offset(v) {
    if ((!v.x) && (!v.y)) {
        return {x:0, y:0};
    }

    if (v.x == 0) {
        if (v.y > 0) {
            return {x:0, y:1};
        } else {
            return {x:0, y:-1};
        }
    } else if (v.y == 0) {
        if (v.x > 0) {
            return {x:1, y:0};
        } else {
            return {x:-1, y:0};
        }
    }

    var angle = Math.atan(v.y / v.x);

    if (angle < rad.d25) {
        return {x:1, y:0};
    } else if (angle < rad.d65) {
        return {x:1, y:1};
    } else if (angle < rad.d115) {
        return {x:0, y:1};
    } else if (angle < rad.d155) {
        return {x:-1, y:1};
    } else if (angle < rad.d205) {
        return {x:-1, y:0};
    } else if (angle < rad.d245) {
        return {x:-1, y:-1};
    } else if (angle < rad.d285) {
        return {x:0, y:-1};
    } else if (angle < rad.d335) {
        return {x:1, y:-1}
    } else {
        return {x:1, y:0};
    }
}

/***
 * There is a lot of mud here!
 * cell.mud is the amount of mud left over from the last iteration.
 * new_mud_amount is the new amount of mud that will be set to this sell.
 *    Some or all of the mud_change may be washed to another cell.
 * added_mud is the difference between the two.
 * moving_mud is the amount of mud_change that will be
 *
 * @param cell
 */
function _calc_mud(cell) {
    var e = cell.terrain.erosion;
    var new_mud_amount = cell.sed_trans_cap * cell.flow_vector.d;
    //   console.log('cell.sed_trans_cap: %s', cell.sed_trans_cap);
    //  console.log('new_mud_amount: %s', new_mud_amount);

    if (new_mud_amount > cell.mud) {
        var added_mud = new_mud_amount - cell.mud;
        if (isNaN(added_mud)){
            throw new Error(util.inspect('added mud is NaN in cell %s, %s', cell.row, cell.col));
        }
        cell.change_in_mud += added_mud;
        cell.height -= added_mud;
    } else {
        var dried_mud = Math.max(cell.mud, e.mud_dry * new_mud_amount);
        if (isNaN(dried_mud)){
            throw new Error(util.inspect('dried_mud is NaN in cell %s, %s', cell.row, cell.col));
        }
        //   console.log('dried mud: %s', dried_mud);
        cell.change_in_mud -= dried_mud;
        new_mud_amount -= dried_mud;
        cell.height += dried_mud;
    }

   // console.log('e.mud_deposition: %s', e.mud_deposition);
  //  console.log('cell.flow_vector.d: %s', cell.flow_vector.d);
    var moving_mud = new_mud_amount * Math.min(1, cell.flow_vector.d * e.mud_deposition);
    if (moving_mud <= 0) {
        return;
    }

    if (isNaN(moving_mud)){
        throw new Error(util.inspect('cell %s, %s moving_mud is NaN', cell.row, cell.col));
    }

    var new_vector = _vector_offset(cell.flow_vector);
    //  console.log('new vector: %s', util.inspect(new_vector));

    new_vector.x += cell.row;
    new_vector.y += cell.col;
    //   console.log('new vector: %s', util.inspect(new_vector));
    var dep_cell = cell.terrain.get(new_vector.x, new_vector.y);

    if (dep_cell) {
     //   console.log('moving_mud: %s', moving_mud);
        dep_cell.change_in_mud += moving_mud;
        cell.change_in_mud -= moving_mud;
    }
}

function _post_mud(cell) {
    if (isNaN(cell.change_in_mud)){
        throw new Error(util.inspect('cell %s, %s change_in_mud is NaN', cell.row, cell.col));
    }
    cell.mud += cell.change_in_mud;
    cell.change_in_mud = 0;
}

function Erosion(terrain, config) {
    if (config) {
        _.extend(this, config);
    }
    this.terrain = terrain;
    this.terrain.erosion = this;
}

Erosion.prototype = {
    terrain:null,

    sim_time:60 * 60 * 24 * 7, // one week

    min_sin:0.1,

    flow_friction:0.005,

    mud_dissolve:0.25,
    mud_dry:0.25,
    mud_deposition:0.5,

    gravity:3.711, // m/s^2 on mars

    sed_cap_k:4.0,

    evaporation_k:0.95,

    _rain_amount:function (cell) {
        var r = Math.random() + Math.random();

        return r * 3 - 2;
    },

    rainfall:function () {
        this.terrain.each_cell(_rain);
    },

    _flow_rate:null,

    flow_rate:function () {
        if (this._flow_rate === null) {
            this._flow_rate = this.gravity * this.sim_time * this.flow_friction
                / (this.terrain.length);
          //  console.log('flow rate: gravity %s * time %s * friction %s / length %s', this.gravity, this.sim_time, this.flow_friction, this.terrain.length);
         //   console.log(' == %s', this._flow_rate);
        }
        return this._flow_rate;
    },

    flux:function () {

        var self = this;

        this.terrain.each_cell(_calculate_flux);
        this.terrain.each_cell(_save_flow_vector);
        this.terrain.each_cell(_release_flux);
        this.terrain.each_cell(_calc_mud);
        this.terrain.each_cell(_post_mud);
    },

    total_water:function () {
        var water = 0;

        this.terrain.each_cell(function (cell) {
            water += cell.water;
        })

        return water;
    },

    set_transport_cap:function () {
        var self = this;

        function _stc(cell) {
            var sin = Math.max(self.min_sin, cell.sin);
           // console.log('sin: %s', sin);
            cell.sed_trans_cap = sin * self.sed_cap_k;
        }

        this.terrain.each_cell(_stc);
    },

    init:function () {
        this.set_transport_cap();
    },

    erode: function(cycles){
        if (!cycles){
            cycles = 1;
        }
        for (var t = 0; t < cycles; ++t){
            this.rainfall();
            this.flux();
        }
    }

}

module.exports = {
    Erosion:Erosion,
    Terrain:Terrain
};