var Cli_Table = require('cli-table');
var Grid = require('./index');
var Cell = require('./Cell');

function Terrain(data, rows, cols, length) {
    this.rows = rows || data.length;
    this.cols = cols || data[0].length;
    console.log('created terrain %s x %s', this.rows, this.cols);
    this.data = data;
    this._cell_data = [];
    this.make_cell_data();
    this.length = length || 500; // meters per region
}

Terrain.prototype = {

    export: function(){
        var rows = [];
        for (var ri = 0; ri < this.rows; ++ri){
            rows[ri] = [];
            for (var ci = 0; ci < this.cols; ++ci){
                var cell = this.get(ri, ci);
                if (!cell){
                    console.log('error: cannot get cell %s, %s', ri, ci);
                } else {
                    rows[ri][ci] = cell.height;
                }
            }
        }
        return rows;
    },

    clone: function(){
        var data = [];

        this.each_cell(function(c){ data.push(c.height)});

        return new Terrain(data, this.rows, this.cols);
    },

    write_to: function(write_path, cb){
        var data = this.export();
        var grid = new Grid(data, this.rows);
        grid.write_to(write_path, cb);
    },

    make_cell_data:function () {
        for (var r = 0; r < this.rows; ++r) {
            if (!this._cell_data[r]) {
                this._cell_data[r] = [];
            }

            for (var c = 0; c < this.cols; ++c) {
                this._cell_data[r][c] = new Cell(this, r, c, this.data[r][c]);
            }
        }
        this.each_cell(_neighborhood);
    },

    get:function (r, c) {
        if ((r < 0) || (c < 0) || (r >= this.rows) || (c >= this.cols)) {
        //    console.log('off terrain request: %s, %s', r, c);
            return null;
        }
        return this._cell_data[r][c];
    },

    range: function(data){
        if (!data){
            data = this.data;
        }

        var out = {min: 0, max: 0}
        var first = true;
        data.forEach(function(rows){
            rows.forEach(function(h){
                if (first){
                    out.min = out.max = h;
                } else if (h > out.max){
                    out.max = h;
                } else if (h < out.min) {
                    out.min = h;
                }
            });
        });

        return out;
    },

    each_cell:function (do_f) {
        this._cell_data.forEach(function (row){
            row.forEach(function(cell){
                do_f(cell);
            })
        })
    },

    echo:function (rows, cols) {
        if (!rows) {
            rows = this.rows;
        }
        if (!cols) {
            cols = this.cols;
        }

        var head = ['rows'];
        var colWidths = [8];
        for (var c = 0; c < cols; ++c) {
            head.push('h ' + c);
            head.push('a ' + c);
            head.push('w ' + c);
            head.push('m ' + c);
        }


        for (var r = 0; r < rows; ++r) {
            colWidths.push(8);
            colWidths.push(8);
            colWidths.push(8);
            colWidths.push(8);
        }
        var table = new Cli_Table({
            head:head,
            colWidths:colWidths
        });

        for (var r = 0; r < rows; ++r) {
            var out_row = [r];
            for (var c = 0; c < cols; ++c) {
                var cell = this.get(r, c);
                out_row.push(cell.height, Math.round(cell.angle * 180 / Math.PI), cell.water, cell.mud);
            }
            table.push(out_row);
        }

        return table.toString();
    },

    slice: function(c1, r1, c2, r2){
        c1 = Math.max(c1, 0);
        r1 = Math.max(r1, 0);

        c2 = Math.min(c2, this.cols - 1);
        r2 = Math.min(r2, this.rows - 1);

        var out = [];

        for (var c = c1; c <= c2; ++c) for (var r = r1; r <= r2; ++r){
            out.push(this.get(r, c));
        }
        return out;
    }
}

function _neighborhood(cell) {
    var neighbor;
    neighbor = cell.parent.get(cell.row, cell.col - 1);
    if (neighbor) {
        cell.neighbors.l = neighbor;
    }

    neighbor = cell.parent.get(cell.row, cell.col + 1);
    if (neighbor) {
        cell.neighbors.r = neighbor;
    }

    neighbor = cell.parent.get(cell.row - 1, cell.col);
    if (neighbor) {
        cell.neighbors.t = neighbor;
    }

    neighbor = cell.parent.get(cell.row + 1, cell.col);
    if (neighbor) {
        cell.neighbors.b = neighbor;
    }


    neighbor = cell.parent.get(cell.row-1, cell.col - 1);
    if (neighbor) {
        cell.neighbors.tl = neighbor;
    }

    neighbor = cell.parent.get(cell.row + 1, cell.col - 1);
    if (neighbor) {
        cell.neighbors.bl = neighbor;
    }

    neighbor = cell.parent.get(cell.row+1, cell.col + 1);
    if (neighbor) {
        cell.neighbors.br = neighbor;
    }

    neighbor = cell.parent.get(cell.row - 1, cell.col + 1);
    if (neighbor) {
        cell.neighbors.tr = neighbor;
    }

    var slope_x = _slope_vector(cell, cell.neighbors.l, cell.neighbors.r);

    var slope_y = _slope_vector(cell, cell.neighbors.t, cell.neighbors.b);

    var slope = Math.sqrt((slope_x * slope_x) + (slope_y * slope_y));
    cell.angle = Math.abs(Math.atan(slope));
    cell.sin = Math.sin(cell.angle);

}

function _slope_vector(cell, back_cell, fore_cell) {
    var slope = 0;
    var dist = 0;
    if (fore_cell) {
        dist += 1;
        slope += fore_cell.height;
    } else {
        slope += cell.height;
    }

    if (back_cell) {
        dist += 1;
        slope -= back_cell.height;
    } else {
        slope -= cell.height;
    }

    if (dist) {
        return slope / dist;
    } else {
        return 0;
    }
}

module.exports = Terrain;