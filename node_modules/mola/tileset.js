var Math_utils = require('util/math');

var import_module = require('mola/import');

/**
 * note - this is NOT a mola plug-in
 * it is a free standing tile divison calculator.
 *
 * Note that i represents the row index of a sector,
 * and j represents the col index of a sector.
 * i goes from west to east, and
 * j goes from north to south.
 * Because j goes in the opposite direction as latitudnal degrees,
 * given that it is a measure of row position which goes north to south,
 * i_to_degree has to express itself as a negative from north rather than
 * a positive from south. 
 * 
 */

function Tileset(tile) {
    this.tile = tile;

    this.pixels_per_col = tile.pixels_per_col; // columns per section
    this.pixels_per_row = tile.pixels_per_row; // rows per section
    this.cols_per_sector = this.get_cols() / this.pixels_per_col;
    this.rows_per_sector = this.get_rows() / this.pixels_per_row;
}

module.exports = Tileset;

Tileset.prototype = {

    // 2D array of tile data
    _data: [],

    load_data: function(callback) {
        var path = this.tile.data_file.image_file;
        var rows = this.tile.rows;
        var cols = this.tile.cols;
        var self = this;
        
        import_module(path, rows, cols, function(err, data){
            console.log(__filename, ': data imported: length = ', data.length);
            self._data = data;
            callback(null, self);
        });
    },

    as_json: function() {
        var out = {
            _id: this.tile._id,
            map_id: this.tile.map_id,
            rows: this.get_rows(),
            cols: this.get_cols(),
            north: this.north(),
            south: this.south(),
            east: this.east(),
            west: this.west()
        }
        return out;
    },

    ij_height: function(i, j) {
        return this._data[i][j];
    },

    get_sector_rows: function(i) {
        return Math.min(this.pixels_per_row, this.tile.rows - (i * this.pixels_per_row));
    },

    get_sector_cols: function(j) {
        return Math.min(this.pixels_per_col, this.tile.cols - (j * this.pixels_per_col));
    },

    get_rows: function() {
        return this.tile.rows;
    },

    get_cols: function() {
        return this.tile.cols;
    },

    j_to_degree: function(j, as_int) {
        j = Math_utils.clamp(j, 0, this.cols_per_sector);
        var out = this.west() + ((j / (this.cols_per_sector)) * this.long_range());
        if (as_int) return parseInt(out);
        return out;
    },

    i_to_degree: function(i, as_int) {
        i = Math_utils.clamp(i, 0, this.rows_per_sector);
        var out = this.north() - ((i / this.rows_per_sector) * this.lat_range());
        if (as_int) return parseInt(out);
        return out;
    },

    lat_range: function() {
        return Math.abs(this.north() - this.south());
    },

    long_range: function() {
        return Math.abs(this.east() - this.west());
    },

    north: function() {
        return parseFloat(this.tile.north);
    },

    south: function() {
        return parseFloat(this.tile.south);
    },

    east: function() {
        return parseFloat(this.tile.east);
    },

    west: function() {
        return parseFloat(this.tile.west);
    }

}