var import_module   = require('./import');
var cti             = require('util/canvas/to_image');
var Canvas          = require('canvas');
var color_module    = require('util/colors/scale');
var oninc           = require('util/oninc');
var fs_utils        = require('util/fs');
var Gate            = require('util/gate');

MOLA = function(path, props) {
    this.path = path;
    this.data = [];
    this.avg = null;
    this.std_dev = null;
    //  this.image_tile_rows = this.get_rows() / 8;
    //  this.image_tile_cols = this.get_cols() / 4;
    for (var p in props) {
        this[p] = props[p];
    }


    console.log('new MOLA: ', this);
}

module.exports = MOLA;

MOLA.prototype = {

    export_tiles: require('./export'),

    read: function(callback) {
        var self = this;
        import_module(this, function(err, data) {
            console.log('read ', data.length, ' ints');
            self.data = data;
            callback(null, self);
        })
    },

    get_rows: function() {
        if (this.end_row) {
            return (this.end_row - this.start_row);
        } else {
            return this.rows;
        }
    },

    get_cols: function() {
        return this.cols;
    },

    get_point_count: function() {
        return this.get_rows() * this.get_cols();
    },

    get_pixels_per_row: function() {
        if (this.pixels_per_row) {
            return this.pixels_per_row;
        } else if (this.row_tiles) {
            return Math.ceil(this.get_rows() / this.row_tiles);
        } else {
            return this.get_rows();
        }
    },

    get_pixels_per_col: function() {
        if (this.pixels_per_col) {
            return this.pixels_per_col;
        } else if (this.col_tiles) {
            return Math.ceil(this.get_cols() / this.col_tiles);
        } else {
            return this.get_cols();
        }
    },

    tile_data: require('./tile_data'),

    _height_to_color: function(v, k, config) {

        var mode = (config.hasOwnProperty('mode')) ? config.mode : 'color';

        switch (mode) {
        case 'height':
            var min = (config.hasOwnProperty('min')) ? config.offset : 0;
            var scale = (config.hasOwnProperty('scale')) ? config.scale : 1;

            var h = v;
            h += min;
            h *= scale;
            h = parseInt(h);

            h = Math.min(255, Math.max(0, h));
            return [h, h, h, 255];
            break

        case 'color':
            var rgba = this.height_color(v);
            rgba[3] = 255;
            break

        default:
            var rgba = this.height_color(v);
            rgba[3] = 255;
        }

        return rgba;
    },

    _height_to_image_data: function(data, id, config) {
        if (!config) {
            config = {};
        }
        if (!config.mode) {
            config.mode = 'color';
        };

        var self = this;
        
        var rgba = _.flatten(_.map(data, function(v, k) {
            return self._height_to_color(v, k, config);
        }, self));

        return rgba;
    },

    chop: function(callback) {
        var tile_rows = Math.ceil(this.get_rows() / this.get_pixels_per_col());
        var tile_cols = Math.ceil(this.get_cols() / this.get_pixels_per_col());
        var gate = new Gate(callback);
        var self = this;
        for (var i = 0; i < tile_rows; ++i) for (var j = 0; j < tile_cols; ++j) {
            var data = self.tile_data(i, j);
            
            var left = parseInt(j * self.get_pixels_per_col());
            var top = parseInt(i * self.get_pixels_per_row());
            var right = Math.min((i + 1) * self.get_pixels_per_row(), self.get_rows());
            var bottom = Math.min((j + 1) * self.get_pixels_per_col(), self.get_cols());
            
            var w = right - left;
            var h = bottom - top;

            self.chop_layers.forEach(function(config) {
                var canvas = new Canvas(w, h);
                var ctx = canvas.getContext('2d');
                var id = ctx.createImageData(w, h);
                var rgba = self._height_to_image_data(data, id);
                console.log('image data generated: ', rgba.slice(0, 16), '...', rgba.slice(-16));
                rgba.forEach(function(v, i){id.data[i] = v;});
                ctx.putImageData(id, 0, 0);
                var path = config.path(self, i, j);
                fs_utils.ensure_file_path(path);
                cti(canvas, path, gate.task_done_callback());
            });
        }
        
        gate.start();
    },

    _measure_bins: require('./_measure_bins'),

    _fill_bins: require('./_fill_bins'),

    measure: require('./measure'),

    height_color: function(h) {
        if (!this.scale) {
            this.scale = require('./scale')();
        }
        var n = color_module.nearest(h, this.scale);
        var rgb = _.map(n.rgb, function(c) {
            return parseInt(Math.min(255, Math.max(0, c)));
        }); // insulating data. 
        return rgb;
    },

    render_image_tile: require('./render_tile'),

    get_data_count: function() {
        var out = 0;
        this.data.forEach(function(r) {
            out += r.length
        });
        return out;
    },

    as_canvas: require('./as_canvas'),

    draw: function(png_path, callback) {
        var canvas = this.as_canvas();
        console.log('writing ', png_path);
        cti(canvas, png_path, callback);
    }
}