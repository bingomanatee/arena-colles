var import_module = require('./import');
var cti = require('util/canvas/to_image');
var Canvas = require('canvas');
var color_module = require('util/colors/scale');
var oninc = require('util/oninc');

MOLA = function(path, props) {
    this.path = path;
    this.data = [];
    this.avg = null;
    this.std_dev = null;

    for (var p in props) {
        this[p] = props[p];
    }

    this.image_tile_rows = this.get_rows() / 8;
    this.image_tile_cols = this.get_cols() / 4;

    console.log('new MOLA: ', this);
}

module.exports = MOLA;

MOLA.prototype = {
    read: function(callback) {
        var self = this;
        import_module(this, function(err, data) {
            console.log('read ', data.length, ' ints');
            self.data = data;
            callback(null, self);
        })
    },

    get_rows: function() {
        if (this.end_row) {
            return (this.end_row - this.start_row);
        } else {
            return this.rows;
        }
    },

    get_cols: function() {
        return this.cols;
    },

    get_point_count: function() {
        return this.get_rows() * this.get_cols();
    },

    _measure_bins: require('./_measure_bins'),
    
    _fill_bins: require('./_fill_bins'),

    measure: require('./measure'),

    height_color: function(h) {
        if (!this.scale) {
            this.scale = require('./scale')();
        }

        var n = color_module.nearest(h, this.scale);
        var rgb = _.map(n.rgb, function(c){return parseInt(Math.min(255, Math.max(0, c))); });
        if (rgb.length != 3 ){
            console.log('bad rgb value ', rgb, ' from ', h);
            throw new Error('rgb error');
        }''
        return rgb; 
    },

    render_image_tile: function(ctx, r, c) {
        var self = this;
        var img_data = [];
        var r_end = Math.min(this.get_rows(), r + this.image_tile_rows);
        var c_end = Math.min(this.get_cols(), c + this.image_tile_cols);

        console.log('rendering tile row ', r, ' ... ', r_end, ', col ', c, ' ... ', c_end);
        
        for (var r_sub = r; r_sub < r_end; ++r_sub) {
            img_data = img_data.concat(this.data[r_sub].slice(c, c_end));
        }

        var h = r_end - r;
        var w = c_end - c;
        var epc = w * h;
        
        if ((w <= 0) || (h <= 0)){
            throw new Error("bad range: w = " + w + ', h = '+ h);
        }
        
        console.log('creating image data: ', w, ' x ', h);
        var id = ctx.createImageData(w, h);

        if (img_data.length != epc){
            console.log('too much image data; expected ', epc, ', retrieved ', img_data.length);
            img_data = img_data.slice(0, epc);
        }

        var base = 0;
        img_data.forEach(function(height) {
            var rgb = self.height_color(height);
            
            id.data[base] = rgb[0];
            id.data[base + 1] = rgb[1];
            id.data[base + 2] = rgb[2];
            id.data[base + 3] = 255;
            
            base += 4;
            // oninc(base, 1000000, _c);
        });

        console.log('putting image data');
        ctx.putImageData(id, c, r);

    },
    
    get_data_count: function(){
        var out = 0;
        this.data.forEach(function(r){ out += r.length});
        return out;
    },

    as_canvas: function() {
        var self = this;
        console.log(__filename, ': l = ', this.data.length);
        if (this.end_row) {
            console.log(__filename, ': writing canvas for ', this.cols, ', ', this.start_row, '... ', this.end_row, ' (', this.rows(), ') rows ');
        } else {
            console.log(__filename, ': writing canvas for c ', this.get_cols(), ', r ', this.get_rows());
        }

        console.log('expected heights: ', this.get_point_count());
        console.log('height count: ', this.get_data_count());
       // if (this.data.length < eh) throw new Error(__filename + 'as_canvas: not enough image data');

        var canvas = new Canvas(this.get_cols(), this.get_rows());
        console.log('NEW CANVAS SIZE', canvas.width, canvas.height);
        var ctx = canvas.getContext('2d');

        for (var r = 0; r < this.get_rows(); r += this.image_tile_rows) {
            for (var c = 0; c < this.get_cols(); c += this.image_tile_cols) {

                this.render_image_tile(ctx, r, c);
            }
        }

        console.log('done drawing image data');
        return canvas;
    },

    draw: function(png_path, callback) {
        var canvas = this.as_canvas();
        console.log('writing ', png_path);
        cti(canvas, png_path, callback);
    }
}