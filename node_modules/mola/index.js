var import_module = require('./import');
var cti = require('util/canvas/to_image');
var Canvas = require('canvas');
var color_module = require('util/colors/scale');
var oninc = require('util/oninc');
var fs_utils = require('util/fs');
var Gate = require('util/gate');
var fs = require('fs');
var util = require('util');
var au = require('util/array');
var pm = require('path');

var open_streams = 0;

MOLA = function(path, props) {
    this.path = path;
    this.data = [];
    this.avg = null;
    this.std_dev = null;
    //  this.image_tile_rows = this.get_rows() / 8;
    //  this.image_tile_cols = this.get_cols() / 4;
    for (var p in props) {
        this[p] = props[p];
    }

    this.render_status = true;
    console.log('new MOLA: ', this);
}

module.exports = MOLA;

MOLA.prototype = {

    export_tiles: require('./export'),

    read: function(callback) {
        var self = this;
        import_module(this, function(err, data) {
            console.log('read ', data.length, ' ints');
            self.data = data;
            callback(null, self);
        })
    },

    get_rows: function() {
        if (this.end_row) {
            return (this.end_row - this.start_row);
        } else {
            return this.rows;
        }
    },

    get_cols: function() {
        return this.cols;
    },

    get_point_count: function() {
        return this.get_rows() * this.get_cols();
    },

    get_pixels_per_row: function() {
        if (this.pixels_per_row) {
            return this.pixels_per_row;
        } else if (this.row_tiles) {
            return Math.ceil(this.get_rows() / this.row_tiles);
        } else {
            return this.get_rows();
        }
    },

    get_pixels_per_col: function() {
        if (this.pixels_per_col) {
            return this.pixels_per_col;
        } else if (this.col_tiles) {
            return Math.ceil(this.get_cols() / this.col_tiles);
        } else {
            return this.get_cols();
        }
    },

    tile_data: require('./tile_data'),

    _height_to_color: require('./height_to_color'),

    _height_to_image_data: require('./_height_to_image_data'),

    _most_frequent: function(data) {
        var survey = {};
        var dl = data.length;
        for (var i = 0; i < dl; ++i) {
            var h = data[i];
            if (survey.hasOwnProperty(h)) {
                ++survey[h];
            } else {
                survey[h] = 1;
            }
        }

        var mh = -1;
        var mc = 0;

        for (var p in survey) {
            if (survey[p] > mc) {
                mh = p;
                mc = survey[p];
            }
        }

        return mh;
    },

    _tile_col: function(j) {
        var c = this.get_pixels_per_col() * j;
        return Math.min(this.get_cols(), c);
    },

    _tile_row: function(i) {
        var r = this.get_pixels_per_row() * i;
        return Math.min(this.get_rows(), r);
    },

    _colors_to_id: function(colors, id) {
        var place = 0;
        for (var il = colors.length, i = 0; i < il; ++i) {
            id.data[place++] = colors[i][0];
            id.data[place++] = colors[i][1];
            id.data[place++] = colors[i][2];
            id.data[place++] = 255;
            if (i < 3) {
                console.log('color ', i, colors[i]);
            }
        }
    },

    _opt_data: function(data) {
        var cache = {
            pos: [],
            neg: []
        }

        function _populate_cache(height, offset) {
            height = parseInt(height);
            var ah = (height < 0) ? -1 * height : height;
            if (height < 0) {
                if (cache.neg[ah]) {
                    cache.neg[ah].push(offset);
                } else {
                    cache.neg[ah] = [offset];
                }
            } else {
                if (cache.pos[ah]) {
                    cache.pos[ah].push(offset);
                } else {
                    cache.pos[ah] = [offset];
                }
            }
        }

        data.forEach(_populate_cache);
        // console.log(cache);
/*
        console.log('cache report: ');
        cache.pos.forEach(function(offsets, height){
            console.log('height ', height, ': ', offsets.length);
        });
        cache.neg.forEach(function(offsets, height){
            console.log('height -', height, ': ', offsets.length);
        });
        */
        return cache;
    },

    _next_tile: function() {
        if (!this.render_status) {
            return;
        }

        if (this._targets.length) {
            var ij = this._targets.pop();
        } else {
            this.render_status = false;
            console.log('$$$$$$$$$$$ ALL TILES RENDERED $$$$$$$$$$$$$$');
            console.log('$$$$$$$$$$$ ALL TILES RENDERED $$$$$$$$$$$$$$');
            return;
        }
        var self = this;
        var gate = new Gate(function() {
            self._next_tile();
        });
        //    gate.debug = true;
        var tile_i = ij[0];
        var tile_j = ij[1];

        var r = this._tile_row(tile_i);
        var c = this._tile_col(tile_j);
        var r_end = this._tile_row(tile_i + 1);
        var c_end = this._tile_col(tile_j + 1);

        var h = r_end - r;
        var w = c_end - c;

        var data = null;
        var opt_data = null;

        var canvas = null;
        var ctx = null;
        var id = null;

        function _do_tile(config) {
            skip = 0;
            console.log('starting ', tile_i, ',', tile_j, '(', w, ' x ', h, ')');
            if (!data) {
                data = self.tile_data(tile_i, tile_j);
                opt_data = self._opt_data(data);
                console.log('data: ', data.length, ', expected: ', w * h);
            }
            if ((!canvas) || (!(canvas.width == w)) || (!(canvas.height == h))) {
                canvas = new Canvas(w, h);
                ctx = canvas.getContext('2d');
                id = ctx.getImageData(0, 0, w, h);
            }
            ctx.fillStyle = '#F00';
            ctx.fillRect(0, 0, w, h);
            var t = new Date().getTime();
            //        var colors = self._height_to_image_data(data, config);
            var colors = self._opt_to_colors(opt_data, config, w * h);
            self._colors_to_id(colors, id);
            ctx.putImageData(id, 0, 0);

            var c_path = config.path(self, tile_i, tile_j);
            fs_utils.ensure_file_path(c_path);
            console.log('rendering ', c_path);
            gate.task_start();
            // cti(canvas, c_path, gate.task_done_callback());
            canvas.toBuffer(function(err, buf) {
                if (err) throw err;
                fs.writeFile(c_path, buf, gate.task_done_callback());
            });
        }

        self.chop_layers.forEach(function(config) {
            var c_path = config.path(self, tile_i, tile_j);
            if (pm.existsSync(c_path)) {
                if ((++skip < 3) || (!(skip % 50))) {
                    console.log('skipping ', c_path);
                }
            } else if (self.data.length) {
                _do_tile(config);
            } else if(!self.reading_data) {
                self.reading_data = true;
                self.read(function() {
                    _do_tile(config)
                });
            }
        });
        gate.start();
    },

    _opt_to_colors: function(cache, config) {
        var out = [];
        var self = this;

        cache.pos.forEach(function(offsets, height) {
            if (offsets) {
                var color = self._height_to_color(height, null, config);
                offsets.forEach(function(o) {
                    out[o] = color;
                })
            }
        })

        cache.neg.forEach(function(offsets, height) {
            if (offsets) {
                var color = self._height_to_color(-1 * height, null, config);
                offsets.forEach(function(o) {
                    out[o] = color;
                })
            }
        })

        return out;
    },

    chop: function(callback) {
        var tile_rows = Math.ceil(this.get_rows() / this.get_pixels_per_col());
        var tile_cols = Math.ceil(this.get_cols() / this.get_pixels_per_col());
        console.log('tiles: ', tile_rows, ' x ', tile_cols, ': ', tile_rows * tile_cols, ' total');
        var self = this;
        this._targets = [];
        for (var i = 0; i < tile_rows; ++i) for (var j = 0; j < tile_cols; ++j) {
            this._targets.push([i, j]);
        }

        this._next_tile();

    },

    _measure_bins: require('./_measure_bins'),

    _fill_bins: require('./_fill_bins'),

    measure: require('./measure'),

    height_color: function(h) {
        if (!this.scale) {
            this.scale = require('./scale')();
        }
        var n = color_module.nearest(h, this.scale);
        var rgb = _.map(n.rgb, function(c) {
            return parseInt(Math.min(255, Math.max(0, c)));
        }); // insulating data. 
        return rgb;
    },

    render_image_tile: require('./render_tile'),

    get_data_count: function() {
        var out = 0;
        this.data.forEach(function(r) {
            out += r.length
        });
        return out;
    },

    as_canvas: require('./as_canvas'),

    draw: function(png_path, callback) {
        var canvas = this.as_canvas();
        console.log('writing ', png_path);
        cti(canvas, png_path, callback);
    }
}

var skip = 0;