var import_module = require('./import');
var cti = require('util/canvas/to_image');
var Canvas = require('canvas');
var color_module = require('util/colors/scale');
var oninc = require('util/oninc');
var fs_utils = require('util/fs');
var Gate = require('util/gate');
var fs = require('fs');
var util = require('util');
var au = require('util/array');

var open_streams = 0;

MOLA = function(path, props) {
    this.path = path;
    this.data = [];
    this.avg = null;
    this.std_dev = null;
    //  this.image_tile_rows = this.get_rows() / 8;
    //  this.image_tile_cols = this.get_cols() / 4;
    for (var p in props) {
        this[p] = props[p];
    }


    console.log('new MOLA: ', this);
}

module.exports = MOLA;

MOLA.prototype = {

    export_tiles: require('./export'),

    read: function(callback) {
        var self = this;
        import_module(this, function(err, data) {
            console.log('read ', data.length, ' ints');
            self.data = data;
            callback(null, self);
        })
    },

    get_rows: function() {
        if (this.end_row) {
            return (this.end_row - this.start_row);
        } else {
            return this.rows;
        }
    },

    get_cols: function() {
        return this.cols;
    },

    get_point_count: function() {
        return this.get_rows() * this.get_cols();
    },

    get_pixels_per_row: function() {
        if (this.pixels_per_row) {
            return this.pixels_per_row;
        } else if (this.row_tiles) {
            return Math.ceil(this.get_rows() / this.row_tiles);
        } else {
            return this.get_rows();
        }
    },

    get_pixels_per_col: function() {
        if (this.pixels_per_col) {
            return this.pixels_per_col;
        } else if (this.col_tiles) {
            return Math.ceil(this.get_cols() / this.col_tiles);
        } else {
            return this.get_cols();
        }
    },

    tile_data: require('./tile_data'),

    _height_to_color: require('./height_to_color'),

    _height_to_image_data: function(data, config) {
        if (!config) {
            config = {};
        }
        if (!config.mode) {
            config.mode = 'color';
        };

        var self = this;
        var colors = [];
        var lp = 0;
        data.forEach(function(v, k) {
            var percent = k / data.length;
            if ((percent - lp) > 0.1) {
                lp = percent;
                console.log(parseInt(100 * percent), '% done with image colors');
            }
            colors.push(self._height_to_color(v, k, config));
        });

        return colors;
    },

    _most_frequent: function(data) {
        var survey = {};
        var dl = data.length;
        for (var i = 0; i < dl; ++i) {
            var h = data[i];
            if (survey.hasOwnProperty(h)) {
                ++survey[h];
            } else {
                survey[h] = 1;
            }
        }

        var mh = -1;
        var mc = 0;

        for (var p in survey) {
            if (survey[p] > mc) {
                mh = p;
                mc = survey[p];
            }
        }

        return mh;
    },

    _tile_col: function(j) {
        var c = this.get_pixels_per_col() * j;
        return Math.min(this.get_cols(), c);
    },

    _tile_row: function(i) {
        var r = this.get_pixels_per_row() * i;
        return Math.min(this.get_rows(), r);
    },

    _next_tile: function() {
        if (this._targets.length) {
            var ij = this._targets.pop();
        } else {
            return console.log('ALL TILES RENDERED');
        }
        var self = this;
        var gate = new Gate(function() {
            self._next_tile();
        });
        //    gate.debug = true;
        var tile_i = ij[0];
        var tile_j = ij[1];

        var r = this._tile_row(tile_i);
        var c = this._tile_col(tile_j);
        var r_end = this._tile_row(tile_i + 1);
        var c_end = this._tile_col(tile_j + 1);
        console.log(r, c, r_end, c_end);

        var h = r_end - r;
        var w = c_end - c;

        console.log('starting ', tile_i, ',', tile_j, '(', w, ' x ', h, ')');

        var data = self.tile_data(tile_i, tile_j);

        console.log('data: ', data.length, ', expected: ', w * h);

        self.chop_layers.forEach(function(config) {
            var canvas = new Canvas(w, h);
            var ctx = canvas.getContext('2d');
            ctx.fillStyle = '#F00';
            ctx.fillRect(0, 0, w, h);

            var colors = self._height_to_image_data(data, config);
            console.log('colors length: ', colors.length, ', expected: ', w * h);

            var id = ctx.getImageData(0, 0, w, h);
            var place = 0;
            for (var il = colors.length, i = 0; i < il; ++i) {
                id.data[place++] = colors[i][0];
                id.data[place++] = colors[i][1];
                id.data[place++] = colors[i][2];
                id.data[place++] = 255;
                if (i < 3) {
                    console.log('color ', i, colors[i]);
                }
            }
            console.log('image data length: ', id.data.length);
            ctx.putImageData(id, 0, 0);

            var c_path = config.path(self, tile_i, tile_j);
            fs_utils.ensure_file_path(c_path);
            console.log('rendering ', c_path);
            gate.task_start();
            // cti(canvas, c_path, gate.task_done_callback());
            canvas.toBuffer(function(err, buf) {
                if (err) throw err;
                fs.writeFile(c_path, buf, gate.task_done_callback());
            });
        });
        gate.start();
    },

    chop: function(callback) {
        var tile_rows = Math.ceil(this.get_rows() / this.get_pixels_per_col());
        var tile_cols = Math.ceil(this.get_cols() / this.get_pixels_per_col());
        console.log('tiles: ', tile_rows, ' x ', tile_cols, ': ', tile_rows * tile_cols, ' total');
        var self = this;
        this._targets = [];
        for (var i = 0; i < tile_rows; ++i) for (var j = 0; j < tile_cols; ++j) {
            this._targets.push([i, j]);
        }

        this._next_tile();

    },

    _measure_bins: require('./_measure_bins'),

    _fill_bins: require('./_fill_bins'),

    measure: require('./measure'),

    height_color: function(h) {
        if (!this.scale) {
            this.scale = require('./scale')();
        }
        var n = color_module.nearest(h, this.scale);
        var rgb = _.map(n.rgb, function(c) {
            return parseInt(Math.min(255, Math.max(0, c)));
        }); // insulating data. 
        return rgb;
    },

    render_image_tile: require('./render_tile'),

    get_data_count: function() {
        var out = 0;
        this.data.forEach(function(r) {
            out += r.length
        });
        return out;
    },

    as_canvas: require('./as_canvas'),

    draw: function(png_path, callback) {
        var canvas = this.as_canvas();
        console.log('writing ', png_path);
        cti(canvas, png_path, callback);
    }
}