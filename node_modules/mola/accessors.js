var MOLA = require('mola');
var Math_utils = require('util/math');

module.exports = {

    get_rows: function() {
        return (this.end_row) ? (this.end_row - this.start_row) : this.rows;
    },

    get_cols: function() {
        return this.cols;
    },

    get_point_count: function() {
        return this.get_rows() * this.get_cols();
    },

    get_pixels_per_row: function() {
        return (this.pixels_per_row) ? this.pixels_per_row : (this.row_tiles) ? Math.ceil(this.get_rows() / this.row_tiles) : this.get_rows();
    },

    get_pixels_per_col: function() {
        return (this.pixels_per_col) ? this.pixels_per_col : (this.col_tiles) ? Math.ceil(this.get_cols() / this.col_tiles) : this.get_cols();
    },

    /**
     * note - may be a fload if pixels per row doesn't go into rows perfectly
     */

    get_tile_rows: function() {
        return (this.pixels_per_row) ? this.get_rows() / (this.pixels_per_row) : (this.row_tiles) ? this.row_tiles : 1;
    },

    get_tile_cols: function() {
        return (this.pixels_per_col) ? this.get_cols() / this.pixels_per_col : (this.col_tiles) ? this.col_tiles : 1;
    },
    
    is_point: function(i, j, r, c){
        if (arguments.length < 3){
            c = this.get_cols();
            r = this.get_rows();
        }
        if ((i < 0) || (i >= this.get_rows())) return false;
        if ((j < 0) || (j >= this.get_cols())) return false;
        return true;
    },
    
    _line_point: function(i, j, idiff, jdiff, r, c){
        
    };
    
    point_line: function(i, j, i2, j2, r, c){
        if (arguments.length < 3){
            c = this.get_cols();
            r = this.get_rows();
        }
                var out = [];
        if(this.is_point(i2, j2) && this.is_point(i, j)){
            if (i == i2){
                var min_j = Math.min(j, j2);
                var max_j = Math.max(j, j2);
                
                var start_index = this._point_index(min_j);
                var length = Math.abs(i - i2) + 1;
                heights = this.data.slice(start_index, start_index + length);
                heights.forEach(function(h, joff){
                    out.push[[{i: i, j: joff + min_j, height: h];
                });
            } else if (j == j2){
                var start_i = Math.min(i, i2);
                var start_index = this._point_index(start_i, j);
                var end_i = Math.max(i, i2);
                
                for (var ii = start_i; ii <= end_i; ++ii){
                    out.push({i: ii, j: j, height: this.data[start_index]});
                    start_index += c;
                }
                return out;
            } else {
                var jdiff = j2 - j;
                var idiff = i2 - i;
                if (Math.abs(idiff) < Math.abs(jdiff)){
                } else {
                }
            }
        }
        else {
            
        }
        return false;
    },
    
    _point_index: function(i, j, r, c){
        if (arguments.length < 3){
            c = this.get_cols();
            r = this.get_rows();
        }
        (c * i) + j;
    },
    
    _ij_height: function(i, j, r, c) {
        if (arguments.length < 3){
            c = this.get_cols();
            r = this.get_rows();
        }
        if (!this.is_point(i,j)) return null;
        var index = (c * i) + j;
        return ((index > 0) && (index < this.data.length)) ? this.data[index] : 0;
    },

    _vectors: [
        [-1, -1],
        [-1, 0],
        [-1, 1],
        [0, -1],
        [0, 0],
        [0, 1],
        [1, -1],
        [1, 0],
        [1, 1]
    ],

    _n_region: function(i, j, rad, r, c){
        var min_x = Math_utils.clamp(j - rad, 0, c - 1);
        var max_x = Math_utils.clamp(j + rad, 0, c - 1);
        var min_y = Math_utils.clamp(i - rad, 0, r - 1);
        var max_y = Math_utils.clamp(i + rad, 0, r - 1);
        var out = [];
        for (var ii = min_y; ii <= max_y; ++ii)
        for (var jj = min_x; jj <= max_x; ++jj)
        {
            var v = this._ij_height(ii , jj);
            if (!isNaN(v)){
                out.push(v);
            }
        }
        return out;
    },
    
    _neighborhood: function(i, j, r, c) {
        if (arguments.length < 3){
            r = this.get_rows();
            c = this.get_cols();
        }
        var out = [false, false, false, false, false, false, false, false, false];
        var offset = 0;
        var self = this;
        this._vectors.forEach(function(v, vi) {
            var ii = v[0] + i;
            var jj = v[1] + j;

            if ((ii > 0) && (ii < r) && (jj > 0) && (jj < c)) {
                out[offset] = self._ij_height(ii, jj);
            }
            ++offset;
        });

        return out;
    },

    load: function() {
        console.log(__filename, '::accessors() loading');

        if (!(MOLA.extensions.hasOwnProperty('accessors') && MOLA.extensions.accessors)) {
            for (var prop in module.exports) {
                if (prop != 'load') {
                    MOLA.prototype[prop] = module.exports[prop];
                }

            }

            MOLA.extensions.accessors = true;
            console.log(__filename, ':: LOADED');
        }

    }

}