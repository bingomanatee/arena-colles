var Canvas = require('canvas');
var Stat = require('util/stat');
var Math_utils = require('util/math');
var fs = require('fs');

module.exports = {

    _vcloud: [
    // [-2, -2],
    [-2, -1],
        [-2, 0],
        [-2, 1],
        //    [-2, 2],
        [-1, -2],
        [-1, -1],
        [-1, 0],
        [-1, 1],
        [-1, 2],

        [0, -2],
        [0, -1],
        //  [0, 0],
        [0, 1],
        [0, 2],

        [1, -2],
        [1, -1],
        [1, 0],
        [1, 1],
        [1, 2],

        //  [2, -2],
        [2, -1],
        [2, 0],
        [2, 1],
        //  [2, 2],
        [-1, -1],
        [-1, 0],
        [-1, 1],
        [0, -1],

        [0, 1],
        [1, -1],
        [1, 0],
        [1, 1]
    ],

    _vcloud2: [

        [-1, 0],
        [0, -1],

        [0, 0],
        [0, 0],

        [0, 1],
        [1, 0], ],

    _downhill: function(i, j, rad, r, c) {
        var base_h = this._ij_height(i, j);
        var min_x = Math_utils.clamp(j - rad, 0, c - 1);
        var max_x = Math_utils.clamp(j + rad, 0, c - 1);
        var min_y = Math_utils.clamp(i - rad, 0, r - 1);
        var max_y = Math_utils.clamp(i + rad, 0, r - 1);
        var candidates = [];
        var low_drop = 0;
        var hi_drop = 0;
        for (var jj = min_x; jj <= max_x; ++jj) for (var ii = min_y; ii <= max_y; ++ii) {
            var h = this._ij_height(ii, jj);
            if (base_h > h) {
                var drop = base_h - h;

                candidates.push({
                    drop: drop,
                    i: ii,
                    j: jj,
                    rad: rad
                });
                if (candidates.length == 1) {
                    low_drop = hi_drop = drop;
                } else if (hi_drop > drop) {
                    hi_drop = drop;
                } else if (low_drop < drop) {
                    low_drop = drop;
                }
            }
        }

        var range = hi_drop - low_drop;

        var candidates = _.sortBy(candidates, function(a, b) {
            return a.drop - b.drop
        });

        return candidates.slice(0, parseInt(Math.max(1, candidates.length / 2)));

    },

    _starfish: function(ctx, ci, i, j, scale, r, c) {
        if (ci < 0) return;
        if (i < 1) return;
        if (i >= r) return;
        if (j < 1) return;
        if (j > c) return;

        // console.log('starfish: ', ci, '(', j, ',', i, ')');
        candidates = this._downhill(i, j, 1, r, c);
        if (!candidates.length) {
            return;
        }
        var self = this;

        candidates.forEach(function(can) { /*if ((cc > 0) && (can.strength >= cc)) { */
            ctx.strokeStyle = 'rgba(0, 0, 0, ' + ci + ')';
            ctx.lineWidth = 1;
            ctx.beginPath();
            var ri = Math_utils.random(-scale / 2, scale / 2);
            var rj = Math_utils.random(-scale / 2, scale / 2);
            ctx.moveTo(j * scale + rj, i * scale + ri);
            ctx.lineTo(can.j * scale, can.i * scale);
            ctx.stroke();
            self._starfish(ctx, ci - 0.05, can.i, can.j, scale, r, c);
            //     cc -= can.strength;
            //  }
        })

    },

    _stipple_point: function(mx) {
        var ii = Math_utils.random(0, mx);
        var ii2 = Math_utils.random(0, mx);
        var ii3 = Math_utils.random(0, mx);
        var m = Math.min(ii, ii2, ii3);
        return (Math.random() > 0.5) ? -1 * m : m;
    },

    _stipple: function(ctx, diff, i, j, r, c, scale, h) {
        var dd = 1;
        var max = 4;
        var iic = (i * scale);
        var jjc = (j * scale);
        var mx = scale * 3;
        var diffm = diff;
        if (h < 0) {
            mx *= 5;
        }
        //  if ((!i % 200)) console.log(diff);
        ctx.fillStyle = 'rgba(255, 255, 255, ' + (0.1 / scale) + ')';
        var d1 = Math.min(1, scale);
        var d2 = Math.min(1 + d1, scale * 2);
        var d3 = Math.min(1 + d2, scale * 3);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.01)';
        while (diffm > 0 && --max) {

            var ii = this._stipple_point(mx);
            var jj = this._stipple_point(mx);

            ctx.fillRect(jj + jjc - d1, ii + iic - d1, 2 * d1, 2 * d1);
            ctx.fillRect(jj + jjc - d2, ii + iic - d2, 2 * d2, 2 * d2);
            ctx.fillRect(jj + jjc - d3, ii + iic - d3, 3 * d3, 3 * d3);
            diffm -= dd;
        }

        var max = 4;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.005)';
        while (diff < 0) {

            var mx = 3 * scale;
            if (h < 0) {
                mx *= 5;
            }
            var ii = this._stipple_point(mx);
            var jj = this._stipple_point(mx);

            ctx.fillRect(jj + jjc - d1, ii + iic - d1, 2 * d1, 2 * d1);
            ctx.fillRect(jj + jjc - d2, ii + iic - d2, 2 * d2, 2 * d2);
            ctx.fillRect(jj + jjc - d3, ii + iic - d3, 3 * d3, 3 * d3);
            diff += dd;
        }
    },

    as_terrainmap: function(scale) {
        var self = this;

        var small_canvas = this.as_canvas();

        var canvas = new Canvas(parseInt(this.get_cols() * scale), parseInt(this.get_rows() * scale));
        console.log('NEW CANVAS SIZE', canvas.width, canvas.height);
        var ctx = canvas.getContext('2d');

        var img = new Canvas.Image();
        img.src = small_canvas.toBuffer();
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        
        delete small_canvas;

        var ts = this.tileset;
        var r = this.get_rows();
        var c = this.get_cols();

        var place = 0;
        var diffs = [];
        var id = ctx.createImageData(canvas.width, canvas.height);

        for (var i = 0; i < r; ++i) for (var j = 0; j < c; ++j) {
            var r3 = this._n_region(i, j, 3, r, c);
            var r2 = this._n_region(i, j, 1, r, c);
            var h = this._ij_height(i, j);
            r2.push(h);

            if (isNaN(h) || (!r2.length)) {
                console.log('cc: ', i, ',', j);
                continue;
            };

            var r3_stat = new Stat(r3);
            var a3 = r3_stat.avg();
            var r2_stat = new Stat(r2);
            var a2 = r2_stat.avg();

            var diff = (a2 - a3);
            var diff = (diff < 0) ? -1 * Math.sqrt(Math.abs(diff)) : Math.sqrt(diff);

            this._stipple(ctx, diff, i, j, r, c, scale, h);

        }

        var stat = new Stat(diffs);

        console.log('average diff: ', stat.avg());
        console.log('stdev: ', stat.std_dev());

        var med_canvas = new Canvas(parseInt(canvas.width / 2), parseInt(canvas.height / 2));
        
        var img = new Canvas.Image();
        img.src = canvas.toBuffer();
        
        med_canvas.getContext('2d').drawImage(img, 0, 0, med_canvas.width, med_canvas.height);
        return med_canvas;
    },

    load: function() {

        require('./accessors').load();

        if (!(MOLA.extensions.hasOwnProperty('terrainmap') && MOLA.extensions.terrainmap)) {
            for (var prop in module.exports) {
                if (prop != 'load') {
                    MOLA.prototype[prop] = module.exports[prop];
                }

            }

            MOLA.extensions.terrainmap = true;
            console.log(__filename, ':: LOADED');
        }

    }
}