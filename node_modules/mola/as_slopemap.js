var MOLA = require('mola');
var Math_util = require('util/math');
var Stat = require('util/stat');
var Canvas = require('canvas');

module.exports = {

    as_slopemap: function() {
        var self = this;

        var canvas = new Canvas(this.get_cols(), this.get_rows());
        console.log('NEW CANVAS SIZE - H', canvas.width, canvas.height);
        var ctx = canvas.getContext('2d');
        var id = ctx.createImageData(canvas.width, canvas.height);

        var base = 0;
        var sample = [];

        var slopes = this.slopes();
      //  var slope_stats = new Stat(slopes);
      //  var avg = slope_stats.avg();
      //  var std_dev = slope_stats.std_dev();
        var min = 4; // avg - (std_dev * 1.5);
        var max = 40;// avg + (std_dev * 1.5);
        var range = max - min;
        var scale = 255 / range;

        slopes.forEach(function(slope, i) {
            var h = (slope - min) / range;
            h = Math_util.clamp(h, 0, 1);
            h = Math.sqrt(h);
            var shade = Math_util.clamp(255 * h, 0, 255, true);
            if (!(i % 50)) {
                sample.push(h);
                console.log('slope: ', slope, 'h: ', h, ', shade: ', shade);
            }

            id.data[base] = id.data[base + 1] = id.data[base + 2] = shade;
            id.data[base + 3] = 255;

            base += 4;
            // oninc(base, 1000000, _c);
        });

        ctx.putImageData(id, 0, 0);
        console.log('done drawing image data');
        return canvas;
    },

    _ij_height: function(i, j) {
        var index = this.get_cols() * i;
        index += j;
        return this.data[index];
    },

    _vectors: [
        [-1, -1],
        [-1, 0],
        [-1, 1],
        [0, -1],
        [0, 0],
        [0, 1],
        [1, -1],
        [1, 0],
        [1, 1]
    ],

    _neighborhood: function(i, j, r, c) {
        var out = [false, false, false, false, false, false, false, false, false];
        var offset = 0;
        var self = this;
        this._vectors.forEach(function(v, vi) {
            var ii = v[0] + i;
            var jj = v[1] + j;

            if ((ii > 0) && (ii < r) && (jj > 0) && (jj < c)) {
                out[offset] = self._ij_height(ii, jj);
            }
            ++offset;
        });

        return out;
    },

    slopes: function() {
        var r = this.get_rows();
        var c = this.get_cols();
        var slopes = [];
        for (var i = 0; i < r; ++i) for (var j = 0; j < c; ++j) {
            var n = this._neighborhood(i, j, r, c);
            n = _.select(n, function(v) {
                return !_.isNull(v)
            });
            var stat = new Stat(n);

            if (!(slopes.length % 50)) {
                console.log('i: ', i, 'j: ', j, 'neghborhood: ', n, ', std_dev: ', stat.std_dev());
            }
            slopes.push(stat.std_dev());
        }
        return slopes;
    },

    load: function() {
        console.log(__filename, '::accessors() loading');

        if (!(MOLA.extensions.hasOwnProperty('slopemap') && MOLA.extensions.slopemap)) {
            for (var prop in module.exports) {
                if (prop != 'load') {
                    MOLA.prototype[prop] = module.exports[prop];
                }

            }

            MOLA.extensions.slopemap = true;
            console.log(__filename, ':: LOADED');
        }

    }

}