
function Point(i, j, grid, props){
    this.i = i;
    this.j = j;
    this.grid = grid;
    this.block = false;
    this.height = 0;
    
    if (props){
        _.default(this, props);
    }
    
}

Point.prototype = {
    __toString: require('./__toString'),
    
    is: function(i, j){
        
        if (typeof i == 'object'){
            j = i.j;
            i = i.i;
        }
        
        return (this.i == i) && (this.j == j);
    },
    /**
     * NOTE - this is not LINEAR distance - this is
     * ORTHOGNAL distance -- the sum of the X and Y vectors
     * from the input. 
     */
    dist: function(i, j){
              
        if (typeof i == 'object'){
            j = i.j;
            i = i.i;
        }
        
        return Math.abs(this.i - i) + Math.abs(this.j - j);
    },
    _code: false,
    code: function(){
        if (!this._code){
            this._code = Point._code(this.i, this.j);
        }
        return this._code;
    }
}

Point._code = function(i, j){
        if (typeof i == 'object') {
        if (i.hasOwnProperty('length')) {
            j = i.shift();
            i = i.shift();
        } else {
            j = i.j;
            i = i.i;
        }
    }
    
    return _letter_code(i) + _letter_code(j);
}

function _letter_code(l){
    l = parseInt(l);
    
    if (l < 0){
        return neg_letters[Math.abs(l)];
    } else {
        return pos_letters[l];
    }
}

pos_letters = 'a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,1,2,3,4,5,6,7,8,9,0'.split(',');
neg_letters = 'A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,!,@,#,$,%,^,&,*,(,)'.split(',');


module.exports = Point;