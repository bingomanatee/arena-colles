var Walk = require('./walk');
var Gate = require('util/gate');

function Random_Walker(model, callback) {
    this.model = model;
}

Random_Walker.prototype = {

    start: function(steps, walk, callback) {
        if (!walk) {
            console.log(__filename, ': Random_Walker.walk(', steps, ')');
            walk = new Walk([{
                i: 0,
                j: 0
            }]);
        }
        this.steps = steps;
        this.step = 2;
        var self = this;

        this.walk_dist(walk, function() {
                self._continue(function(counts) {
                    for (p in counts) {
                        if (counts[p] > 0) {
                            return true; // at least one walk was walked from 
                        }
                    }
                    return ++self.step;
                });
            /** TODO: establish a control context around _continue. 
        });
    },

    _continue_walks: function(err, cursor, counter, d, callback) {
        var self = this;

        if (err) {
            console.log(__filename, '**** ERROR walking ****', err);
            throw err;
        }

        cursor.each(function(item) {

            if (item) {
                counter[d]++;
                console.log('updaing ', counter, ' based on ', item._id);
            }

            var walk = Walk.load(item);

        });

    },

    _continue: function(callback) {

        var gate = new Gate(callback);

        function _gate_end() {
            gate.end();
        }
        var self = this;

        var options = {
            cursor: true,
            limit: 1000
        };

        var counter = {
            n: 0,
            e: 0,
            s: 0,
            w: 0
        };

        function _continue_d(step, d, counter, callback) {

            var query = {
                steps: step
            };
            query["children." + d] = false;

            this.m.find(query, function(err, cursor) {
                self._continue_walks(err, cursor, counter, d, _gate_end);
            }, options);
        }

        _continue_d(this.step, 'n');
        _continue_d(this.step, 's');
        _continue_d(this.step, 'e');
        _continue_d(this.step, 'w');
    },

    /**
     * walk_dist grabs all recorded walks of a given length
     * and walks one point from each of them in each direction.
     * 
     * subgating - this.gate counts the spawning and mutating of each generation as a task;
     * gen_gate counts the mutating of each walk within a generation as a task.
     */
    walk_dist: function(from_walk, callback) {
        // console.log(__filename, ': from ', from_walk);
        var self = this;

        var gate = new Gate(callback);

        function _end_gate() {
            get.end_task();
        }

        gate.start_tasks(4);
        this._walk_n(self, from_walk, _end_gate);
        this._walk_s(self, from_walk, _end_gate);
        this._walk_e(self, from_walk, _end_gate);
        this._walk_w(self, from_walk, _end_gate);
        gate.start();
    },

    _walk_n: function(self, from_walk, callback) {
        if (from_walk.last_direction() != 's') {
            var new_walk = from_walk.n();

            if (new_walk) {
                new_walk.put(self.model, callback, from_walk, 'n');
            }
        } else {
            callback();
        }
    },

    _walk_w: function(self, from_walk, callback) {
        if (from_walk.last_direction() != 'e') {
            var new_walk = from_walk.w();

            if (new_walk) {
                new_walk.put(self.model, callback, from_walk, 'w');
            }
        } else {
            callback();
        }
    },

    _walk_s: function(self, from_walk, callback) {

        if (from_walk.last_direction() != 'n') {
            var new_walk = from_walk.s();

            if (new_walk) {
                new_walk.put(self.model, callback, from_walk, 's');
            }
        } else {
            callback();
        }
    },

    _walk_e: function(self, from_walk, callback) {
        if (from_walk.last_direction() != 'w') {
            var new_walk = from_walk.e();

            if (new_walk) {
                new_walk.put(self.model, callback, from_walk, 'e');
            }
        } else {
            callback();
        }
    }
}


module.exports = Random_Walker;