function Walk(rw) {
    this.rw = rw;
    this.steps = [];
}

Walk.prototype = {
    
    last: function(){
        return this.steps[this.steps.length - 1];
    },
    
    put: function(m, callback) {

        var points = this.steps;
        var first = this.steps[0];
        var first = this.rw.grid.p(first);
        var last = this.rw.grid.p(this.last());
        
        try {
            var dist = first.dist(last);
        } catch(err) {
            var dist = 0;
        }
        
        try {
            var straightness = dist / this.steps.length;
        } catch (err){
            var straighness = 0;
        }

        var walk = {
            dist: dist,
            straightness: straightness,
            points: points,
            point_count: this.steps.length,
            last: this.last()
        };
        
      //  console.log('Putting ', walk);
      //  callback();
                m.put(walk, callback);
    },

    start: function(i, j) {
        var grid = this.rw.grid;
        this.steps.push({i: this.rw.i, j: this.rw.j});
    },

    __toString: function() {
        var out = '';
        this.steps.forEach(function(p) {
            out += ' ' + p.i + ',' + p.j;
        });
        return out;
    },

    /**
     *
     * This method checks whether the points in this walk
     * are redundant - checks all the points starting from
     * the passed value, or by default all of them.
     * It works by picking the point at the index,
     * comparing that point to all the ones before it,
     * then picking the next one til it runs out of points
     * or finds an overlap.
     *
     * This is more efficient because in general you usually check
     * only the last few points.
     * 
     * Note the passed parameter is the number of points AT THE END
     * OF THE WALK that you want to check. 
     *
     */
    overlap: function(from_end) {
        if (!from_end) {
            from_end = 1;
        }
        while (from_end < this.steps.length) {

            var index_to_check = this.steps.length - from_end;

            var p = this.steps[index_to_check];
            p = this.rw.grid.p(p);
            
            for (var pi = 0; pi < index_to_check; ++pi) {
                if (p.is(this.steps[pi])) {
                    return true;
                }
            }

            ++from_end;
        }
        return false;
    },

    n: function() {
        var last =  this.last();
        var n = this.rw.grid.p(last.i, last.j - 1);

        if (!n) {
            return false;
        }

        var w = this._copy();
        w.steps.push({i: n.i, j: n.j});
        return w;
    },

    s: function() {
       
        var last =  this.last();
        var n = this.rw.grid.p(last.i, last.j + 1);

        if (!n) {
            return false;
        }

        var w = this._copy();
        w.steps.push({i: n.i, j: n.j});
        return w;
    },

    e: function() {

        var last =  this.last();
        var n = this.rw.grid.p(last.i + 1, last.j);

        if (!n) {
            return false;
        }

        var w = this._copy();
        w.steps.push({i: n.i, j: n.j});
        return w;
    },

    w: function() {
        
        var last =  this.last();
        var n = this.rw.grid.p(last.i - 1, last.j);

        if (!n) {
            return false;
        }

        var w = this._copy();
        w.steps.push({i: n.i, j: n.j});
        return w;
    },

    _copy: function() {
        var w = new Walk(this.rw);

        this.steps.forEach(function(p) {
            w.steps.push(p);
        });
        return w;
    },

    walked: function(i, j) {
        if (typeof i == 'object') {
            j = i.j;
            i = i;
        }

        for (var c = 0; c < this.points.length; ++c) {
            if (this.poiints[c].is(i, j)) return true;
        }

        return false;
    },

    go: function(i, j) {
        try {
            var p = this.grid.p(i, j);

            if (this.walked(p)) {
                return false;
            } else {
                this.points.push(p);
                return true;
            }

            return true;
        } catch (e) {
            return false;
        }
    }

}

module.exports = Walk;