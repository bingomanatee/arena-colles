/**
 * Haven't you always wished you were larger?
 * This scales a heightmap and uses a "gravitational influence model"
 * to interpolate the data into the new grid.
 *
 * @param tile Object:mapimage_tile
 * @param scale int - the multiplier that determines the size of the original grid.
 *                    should be an integer, 2 or more.
 *
 *    gravity: the power by which the influence of distant heights is diminished. A power of two reflects the
 *             influence of mass, but that is not necessarily the best way to model height weights...
 *             Should be a number >= 1; ideally in the 1.5...3 range. The greater the max_dist value, the lower gravity should be.
 *             consider that max_dist ^ gravity will be the smallest influence weight for a point of data.
 *             so at the default values of dist 3, gravity 2, scale 2, the smallest influence weight would be 1/36;
 *             if you had max_dist at 4 , gravity 4, and scale 3, the smallest weight would be 1/20,000 - pretty weak!
 *             at that scale, a gravity of 1.5 gives you a max influence of 1/41 - more relevant.
 *
 *    max_dist: the farthest a point can be from a desination sample before its influence is ingored.
 *
 *    both of these values are relative to the original grid dimensions.
 */

module.exports = function(tile, scale) {
    this.scale = Math.max(2, parseInt(scale));
    this.tile = tile;
    this.data = this.scale_data();
    this.i_start = this.tile.heights.length;
    this.j_start = this.tile.heights[0].length;
    this.i_height_scaled = i_start * this.scale;
    this.j_height_scaled = j_start * this.scale;

    this.gravity = 2;
    this.max_dist = 3;
}

module.exports.prototype = {

    scale_data: function() {

        var out = [];
        for (var i = 0; i < this.i_height_scaled; ++i) {
            var row = [];
            for (var j = 0; j < this.j_height_scaled; ++j) {
                row.push([]);
            }
            out.push(row);
        }

        return out;
    },

    bez_data: function() {
        var max_dist_scaled = this.max_dist * this.scale;

        for (var i = 0; i < this.i_start; ++i) {
            for (var j = 0; j < this.j_start; ++j) {
                var i_scaled = i * this.scale;
                var j_scaled = j * this.scale;
                var height_value = this.tile.heights[i][j];
                var i_max = Math.min(i_scaled + max_dist_scaled, this.i_height_scaled - 1);
                var j_max = Math.min(j_scaled + max_dist_scaled, this.j_height_scaled - 1);
                for (var i_range = Math.max(0, i_scaled - max_dist_scaled); i_range <= i_max; ++i_range) {
                    for (var j_range = Math.max(0, j_scaled - max_dist_scaled); j_range <= j_max; ++j_range) {

                        var dist = _dist(i_range, j_range, i_scaled, j_scaled);
                        if (dist <= max_dist_scaled) {
                            var influence = {
                                height: height_value,
                                weight: 1 / Math.max(0.5,  Math.pow(dist, this.gravity))
                            };

                            this.data[i_scaled][j_scaled].push(influence);
                        }
                    } // end j_range loop
                } // end i_range loop
            } // end j loop
        } // end i loop

        var self = this;

        this.data.forEach(function(rows, i){
            rows.forEach(function(values, j){
                var weight_total = 0;
                var height_total = 0;
                values.forEach(function(value){
                    weight_total += value.weight;
                    height_total += (value.weight * value.height);
                });

                this.data[i][j] = weight_total ? parseInt(height_total/weight_total) : 0;
            });
        });
    }

}

function _dist(i, j, i2, j2) {
    return Math.sqrt((i * i) + (j * j));
}