var mu = require('util/math');

function _quadrant(data, x, y) {

    if (x > 0 && x < data[0].length - 1 && y > 0 && y < data.length - 1) {
        return ['center', 'middle'];
    }
    var lr = 'center';
    var tb = 'middle';
    if (x == 0) {
        lr = 'left';
    } else if (x >= data[0].length - 1) {
        lr = 'right';
    }

    if (y == 0) {
        tb = 'top';
    } else if (y >= data.length - 1) {
        tb = 'bottom';
    }
    return [lr, tb];
}

function _degree_lat(y, data, image) {
    return ((image.north * y) + (image.south * (data.length - y))) / data.length;
}

function _cos_degree(deg) {
    return Math.cos(deg * Math.PI / 180);
}

var ee = 4
module.exports = function(data, x, y, zoom) {
    //var lat = _degree_lat(y, data);
    // var cos = _cos_degree(lat);
    var lat_m_per_point = 500 / zoom; // the higher/lower you go, the smaller the lateral distance between measurements.
    // * Math.max(0.001, Math.abs(cos)
    var lon_m_per_point = 500 / zoom;
    var lat_traverse = 0;
    var lon_traverse = 0;
    var q = _quadrant(data, x, y);
    
    // @TODO: the four corners. Shouldn't matter too much in the larger scheme
    switch (q[0]) {
        case 'center':
            var left = data[y][x - 1];
            var right = data[y][x + 1];

            lon_traverse = (right - left) / (2 * lon_m_per_point);

            switch (q[1]) {
                case 'middle':
                    if (ee > 0) {
                        console.log('getting image ', x, y, zoom);
                    }
                    // common case; main middle

                    var top = data[y - 1][x];
                    var bottom = data[y + 1][x];

                    lat_traverse = (top - bottom) / (2 * lat_m_per_point);

                    if (ee-- > 0) {
                        console.log(__filename, 'left:', left, 'right:', right);
                        console.log('... top:', top, 'bottom:', bottom);
                        console.log('... lat_traverse: ', lat_traverse);
                        console.log('... lon_traverse: ', lon_traverse);

                    }

                    break;
            }

            break;
    }
    var r = mu.clamp((lon_traverse * 127) + 127, 0, 255, true);
    var g = mu.clamp((lat_traverse * 127) + 127, 0, 255, true);
    return [r, g, 255, 255];
}