var mu = require('util/math');

function _quadrant(data, x, y) {

    if (x > 0 && x < data[0].length - 1 && y > 0 && y < data.length - 1) {
        return ['center', 'middle'];
    }
    var lr = 'center';
    var tb = 'middle';
    if (x == 0) {
        lr = 'left';
    } else if (x >= data[0].length - 1) {
        lr = 'right';
    }

    if (y == 0) {
        tb = 'top';
    } else if (y >= data.length - 1) {
        tb = 'bottom';
    }
    return [lr, tb];
}

function _degree_lat(y, data, image){
 return ((image.north * y) + (image.south * (data.length - y))) / data.length;
}

function _cos_degree(deg){
    return Math.cos(deg * Math.PI/180);
}

module.exports = function(data, x, y, ctx_image) {
    var lat = _degree_lat(y, data, ctx_image);
    var cos = _cos_degree(lat);
    var lat_m_per_point = 500 * Math.max(0.001, Math.abs(cos)); // the higher/lower you go, the smaller the lateral distance between measurements.
    var lon_m_per_point = 500;
    var lat_traverse = 0;
    var lon_traverse = 0;
    var q = _quadrant(data, x, y);

    // @TODO: the four corners. Shouldn't matter too much in the larger scheme
    switch (q[0]) {
        case 'center':
            var left = this.data[y][x - 1];
            var right = this.data[y][x + 1];

             lon_traverse = (right - left) / (2 * lon_m_per_point);

            switch (q[1]) {
                case 'middle':
                    // common case; main middle

                    var top = this.data[y - 1][x];
                    var bottom = this.data[y + 1][x];

                    lat_traverse = (top - bottom) / (2 * lat_m_per_point);
                    
                break;
            }
            
        break;

        return [(lon_traverse * 127) + 127, (lat_traverse * 127) + 127, 255, 255];
    }
    /*
     var rb = h / 2;
     var r = mu.clamp(rb, 0, 255, true);
     var gb = (Math.abs(h) / 10);
     var g = mu.clamp(gb, 0, 255, true);
     if (h < 0) g = 255 - g;
     if (h > 0) {
     var bb = h / 15 - 100; //Math.abs(Math.sqrt(h));
     } else {
     var bb = 255 +  h / 100;

     }
     var b = mu.clamp(bb, 0, 255, true);
     if (ctx_image) {
     ctx_image.data[base] = r
     ctx_image.data[base + 1] = g
     ctx_image.data[base + 2] = b
     ctx_image.data[base + 3] = 255;
     } else {
     return [r, g, b];
     } */
}