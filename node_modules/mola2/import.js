var fs = require('fs');
var bin = require('util/binary');
var au = require('util/array');
var pm = require('path');
var neobuffer = require('neobuffer');
var util = require('util');

/**
 * reads in a byte stream of data;
 * returns a 2d array of ints
 *
 * @param image : a src of data having {image_file: "..", rows: int, cols:int};
 * @param callback(err, int_rows);
 */
module.exports = function(image, callback) {
    console.log(__filename, ': input ', image);

    var path = image.image_file,
        rows = image.rows,
        cols = image.cols;
    // console.log(__filename, ': reading ', path, 'r',rows,'c',cols);
    if (!pm.existsSync(path)) {
        throw new Error(__filename + ': cannot find ' + path);
    }

    //  var file_info = fs.statSync(path);
    //  console.log(file_info);

    var read_config = {
        bufferSize: 64 * 1024
    };

    var ints = [];
    var int_rows = [];

    var handle = fs.createReadStream(path, read_config);
    var read_size = 0;
    var last_percent = 0;
    var data_count = 0;
    var expected = rows * cols * 2;

    handle.on('data', function(data_buffer) {
        var nbuffer = new neobuffer.Buffer(data_buffer.length);
        data_buffer.copy(nbuffer);

        for (var s = 0; s < nbuffer.length; s += 2) {
            ints.push(parseInt(nbuffer.readInt16(s, 'big')));
        }
        while (ints.length >= cols) {
           // console.log('ints length: ', ints.length);
            var slice = ints.slice(0, cols);
          //  console.log('slice length', slice.length);
            int_rows.push(slice);
            ints = ints.slice(cols);
        }
        read_size += data_buffer.length;
        var percent = read_size * 100 / expected;
        if ((percent - last_percent) >= 10) {
            console.log(parseInt(percent), '% read ', read_size, ' of ', expected, ' ints');
            last_percent = percent;
        }
    });

    handle.on('end', function() {
        if (ints.length) {
            int_rows.push(ints);
        }
        _analyze_heights(int_rows, image);
        //  console.log(__filename, ': flattening ', int_rows.length, 'int sets; ', data_count, ' on_datas');
        callback(null, int_rows);
    })

}


function _analyze_heights(heights, image) {
    if (image.rows != heights.length) {
        console.log('AH: bad row count; expected', image.rows, ', actual = ', heights.length);
    }
    var last_value = 0;
    for (var i = 0; i < heights.length; ++i) {
        var row = heights[i];

        if (row.length != image.cols) {
            util.log(['AH: bad col count; expected', image.cols, ', actual = ', heights[i].length].join(' '));
        }

      /*  if (i < 20) {
            for (var j = 0; j < 20; ++j) {
                util.log(row.slice(j, 20 + j).join(','));

            }
            util.log('');
        }
*/
    }

    util.log(['row 0, 120..130', util.inspect(heights[0].slice(120, 130))].join(' '));

}