var fs = require('fs');
var bin = require('util/binary');
var au = require('util/array');
var pm = require('path');
var neobuffer = require('neobuffer');
var util = require('util');

/**
 * reads in a byte stream of data;
 * returns a 2d array of ints
 *
 * @param image : a src of data having {image_file: "..", rows: int, cols:int};
 * @param callback(err, int_rows);
 */
module.exports = function(image, callback, zoom) {
    console.log(__filename, ': input ', image.image_file);

    var path = image.image_file,
        rows = image.rows,
        cols = image.cols;
    // console.log(__filename, ': reading ', path, 'r',rows,'c',cols);
    if (!pm.existsSync(path)) {
        throw new Error(__filename + ': cannot find ' + path);
    }

    if ((zoom > 1) && (pm.existsSync(path + 'x' + zoom))) {
        // console.log('reading cached zoom file', path + 'x' + zoom);
        
        var zoomed_image = {image_file: path + 'x' + zoom,
            rows: image.rows / zoom,
            cols: image.cols / zoom
        };
        return module.exports(zoomed_image, callback, 1);
    }

    //  var file_info = fs.statSync(path);
    //  console.log(file_info);

    var read_config = {
        bufferSize: 64 * 1024
    };

    var ints = [];
    var int_rows = [];

    var handle = fs.createReadStream(path, read_config);
    var read_size = 0;
    var last_percent = 0;
    var data_count = 0;
    var expected = rows * cols * 2;

    handle.on('data', function(data_buffer) {
        var nbuffer = new neobuffer.Buffer(data_buffer.length);
        data_buffer.copy(nbuffer);

        for (var s = 0; s < nbuffer.length; s += 2) {
            ints.push(parseInt(nbuffer.readInt16(s, 'big')));
        }
        while (ints.length >= cols) {
            // console.log('ints length: ', ints.length);
            var slice = ints.slice(0, cols);
            //  console.log('slice length', slice.length);
            int_rows.push(slice);
            ints = ints.slice(cols);
        }
        read_size += data_buffer.length;
        var percent = read_size * 100 / expected;
        if ((percent - last_percent) >= 10) {
            // console.log(parseInt(percent), '% read ', read_size, ' of ', expected, ' ints');
            last_percent = percent;
        }
    });

    handle.on('end', function() {
        if (ints.length) {
            int_rows.push(ints);
        }
        _analyze_heights(int_rows, image);
        //  console.log(__filename, ': flattening ', int_rows.length, 'int sets; ', data_count, ' on_datas');


        if (zoom > 1) {
            var new_image_data = [];
            for (var i = 0; i < int_rows.length; i += zoom) {
                var row = [];
                for (var j = 0; j < int_rows[0].length; j += zoom) {
                    row.push(int_rows[i][j]);
                }
                new_image_data.push(row);
            }
            int_rows = new_image_data;
            // console.log('saving for posterity: ', path + 'x' + zoom);
            var zoom_stream = fs.createWriteStream(path + 'x' + zoom);
            var neobuff = new neobuffer.Buffer(int_rows.length * int_rows[0].length * 2);
            var start = 0;
            int_rows.forEach(function(row) {
                row.forEach(function(h) {
                    neobuff.writeInt16(h, start, 'big');
                    start += 2;
                })
            })
            var buffer = new Buffer(neobuff.length);
            neobuff.copy(buffer);
            zoom_stream.on('data', function(){
                // console.log('writing data');
            })
            zoom_stream.on('close', function() {
                // console.log('done with zooming save');
                callback(null, int_rows);
            });
            zoom_stream.write(buffer);
            zoom_stream.end();
            // console.log('written cached zoom buffer');
        } else {
            callback(null, int_rows);
        }

    })

}


function _analyze_heights(heights, image) {
    if (image.rows != heights.length) {
        // console.log('AH: bad row count; expected', image.rows, ', actual = ', heights.length);
    }
    var last_value = 0;
    for (var i = 0; i < heights.length; ++i) {
        var row = heights[i];

        if (row.length != image.cols) {
            util.log(['AH: bad col count; expected', image.cols, ', actual = ', heights[i].length].join(' '));
        }

        /*  if (i < 20) {
         for (var j = 0; j < 20; ++j) {
         util.log(row.slice(j, 20 + j).join(','));

         }
         util.log('');
         }
         */
    }

    // util.log(['row 0, 120..130', util.inspect(heights[0].slice(120, 130))].join(' '));

}