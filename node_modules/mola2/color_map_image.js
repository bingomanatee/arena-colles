var mu = require('util/math');
var mars_scale = require('mola2/scale')()
var color_util = require('util/colors/scale');
var _ = require('underscore');
var Stat = require('util/stat');

var echo = 0;
var rg_min = 2;
var rg_max = 8;
var tile_size = 100;
var shade_per_diff_per_dist = 2; // every 45 degree rise nearby adds 10% to the shadow
var rg = 6;
function _shadow(data, x, y) {
    // if (y > 1000) return 0;
    var h = data[y][x];

    if (h < 0) return 1;

    var min_x = Math.max(0, x - rg);
    var max_x = Math.min(data[0].length - 1, x + rg);

    var min_y = Math.max(0, y - rg);
    var max_y = Math.min(data.length - 1, y + rg);

    var diffs = [];
    var shading = 0;
    var measures = 0;

    var points = [];

    for (var xscan = min_x; xscan <= max_x; ++xscan) {
        for (var yscan = min_y; yscan <= max_y; ++yscan) {
            /*
            var xdist = (xscan - x);
            var ydist = (yscan - y);
            var distance =  50 * Math.sqrt((xdist * xdist) + (ydist * ydist));

            if (distance) {
                var rise = Math.abs(data[yscan][xscan] - h);

                var diff_per_dist = rise / distance;

                if (!(echo % 1000000)) {
                    console.log('diff_per_dist: ', diff_per_dist);
                }
                shading += diff_per_dist;
                measures += 1;
            }
*/
            points.push(data[yscan][xscan]);
        }
    }
/*
    var out = 1 - (shading / measures);

    if (!(echo % 1000000)) {
        console.log('x:', x, 'y:', y);
        console.log('cost_of_dpd', shade_per_diff_per_dist);
        console.log('min_x: ', min_x, 'max_x', max_x);
        console.log('shade %:', out);
    }

    return Math.pow(out,1.5);
*/
    var stat = new Stat(points);
    var std = stat.std_dev();

    if (!(echo % 1000000)) {

        console.log('x:', x, 'y:', y);
        console.log('std: ', std);
    }
    var out =  Math.min(1, 5 /Math.sqrt(std));
    if (h > stat.avg()){
        out = 2 - out;
    }

    return out;
}

module.exports = function(data, x, y, zoom) {
    var h = data[y][x];

    var measure = color_util.nearest(h, mars_scale);

    var shadow = _shadow(data, x, y, echo);

    if (!(++echo % 1000000)) {
        console.log('measure of', h, 'is', measure, 'shade:', shadow);
    }

    return _shade(measure.rgb, shadow);
}

function _shade(rgb, shadow) {

    var out = [mu.clamp(rgb[0] * shadow, 0, 255, true), mu.clamp(rgb[1] * shadow, 0, 255, true), mu.clamp(rgb[2] * shadow, 0, 255, true), 255];

    return _.map(out, function(v) {
        return mu.clamp(v, 0, 255, true)
    });
}

/*
 module.exports = function(h, base, ctx_image) {
 var rb = h / 2;
 var r = mu.clamp(rb, 0, 255, true);
 var gb = (Math.abs(h) / 10);
 var g = mu.clamp(gb, 0, 255, true);
 if (h < 0) g = 255 - g;
 if (h > 0) {
 var bb = h / 15 - 100; //Math.abs(Math.sqrt(h));
 } else {
 var bb = 255 +  h / 100;

 }
 var b = mu.clamp(bb, 0, 255, true);
 if (ctx_image) {
 ctx_image.data[base] = r
 ctx_image.data[base + 1] = g
 ctx_image.data[base + 2] = b
 ctx_image.data[base + 3] = 255;
 } else {
 return [r, g, b];
 }
 } */