/**
 * Pipe calls the same function with different parameters;
 * it allows for asynchronous but single threaded activity.
 *
 * action has a profile self (the pipe),
 * params (the current )
 */

function Pipe(callback, action, param_array, freq, static_params) {
    this.callback = callback;

    if (typeof action != 'function') {
        throw new Error(__filename + ': non function passed as action');
    }

    this.action = action;
    this.param_array = param_array ? param_array : [];
    this.static_params = static_params ? static_params : false;
    this.freq = freq ? freq : 100;
    this.idle = true;
    this.done = false;
    this.iv = null;
}

module.exports = Pipe;

Pipe.prototype = {

    _iv: function() {
        var self = this;
        return function() {
            self.check_pipe();
        };
    },

    start: function() {
        this.iv = setInterval(this._iv(), this.freq);
    },

    check_pipe: function() {
        if (this.idle) {
            this.idle = false;
            this.act();
        }
    },

    act: function() {
        var self = this;
        /**
         * Pipe allows for an array of changing parameters
         * -- howver they are optional.
         * The param_array running out of params
         * doesn't automatically trigger finish - that has to be done inside action
         *  by calling pipe.finish(); this is why pipe is the first parameter
         *  of action. 
         */
        
        if (this.param_array.length) {
            var params = this.param_array.shift();
        } else {
            params = false;
        }
        
        this.idle = false;
        this.action(self, params, this.action_done_callback(), this.static_params);
    },

    action_done_callback: function() {
        var self = this;
        return function() {
            self.idle = true;
        }
    },

    /**
     * Finish will prevent further functions from being launched.
     * It won't abort the execution of a function being executied.
     */
    
    finish: function() {
        clearInterval(this.iv);
        this.callback(this);
        this.done = true;
    }

}